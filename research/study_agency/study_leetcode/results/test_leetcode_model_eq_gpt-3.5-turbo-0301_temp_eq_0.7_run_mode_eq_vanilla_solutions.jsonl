{"task_id": "LeetCode-Hard/0", "completion": "\nfrom typing import List\n\ndef minReverseOperations(n: int, p: int, banned: List[int], k: int) -> List[int]:\n    if p in banned:\n        return [-1] * n\n    ans = [0] * n\n    for i in range(n):\n        if i in banned or i == p:\n            ans[i] = -1\n    for i in range(n):\n        if ans[i] == -1:\n            continue\n        l, r = max(0, i-k+1), min(n-k, i)+1\n        if p >= l and p < r:\n            ans[i] = abs(p-i) // k\n        else:\n            ans[i] = min(abs(l-p) // k + (i-l+k-1) // k, abs(r-p) // k + (r-i+k-1) // k)\n    return ans\n", "raw_completion": "```python\nfrom typing import List\n\ndef minReverseOperations(n: int, p: int, banned: List[int], k: int) -> List[int]:\n    if p in banned:\n        return [-1] * n\n    ans = [0] * n\n    for i in range(n):\n        if i in banned or i == p:\n            ans[i] = -1\n    for i in range(n):\n        if ans[i] == -1:\n            continue\n        l, r = max(0, i-k+1), min(n-k, i)+1\n        if p >= l and p < r:\n            ans[i] = abs(p-i) // k\n        else:\n            ans[i] = min(abs(l-p) // k + (i-l+k-1) // k, abs(r-p) // k + (r-i+k-1) // k)\n    return ans\n```"}
{"task_id": "LeetCode-Hard/29", "completion": "\ndef beautifulPartitions(s: str, k: int, minLength: int) -> int:\n    primes = set(['2', '3', '5', '7'])\n    MOD = 1000000007\n\n    def isPrime(num):\n        if num in primes:\n            return True\n        return False\n\n    memo = {}\n\n    def dp(index, substrings, nonprime_length):\n        nonlocal k, minLength\n        if substrings == k and nonprime_length == 0:\n            return 1\n        if substrings > k:\n            return 0\n        if index >= len(s):\n            return 0\n        if (index, substrings, nonprime_length) in memo:\n            return memo[(index, substrings, nonprime_length)]\n\n        result = dp(index + minLength, substrings + 1, 0)\n        for i in range(index + minLength, len(s)):\n            if isPrime(s[index]) and not isPrime(s[i]) and i - index + 1 >= minLength:\n                result += dp(i + 1, substrings + 1, nonprime_length + i - index + 1)\n                result %= MOD\n        memo[(index, substrings, nonprime_length)] = result\n        return result\n\n    return dp(0, 0, 0)\n", "raw_completion": "```python\ndef beautifulPartitions(s: str, k: int, minLength: int) -> int:\n    primes = set(['2', '3', '5', '7'])\n    MOD = 1000000007\n\n    def isPrime(num):\n        if num in primes:\n            return True\n        return False\n\n    memo = {}\n\n    def dp(index, substrings, nonprime_length):\n        nonlocal k, minLength\n        if substrings == k and nonprime_length == 0:\n            return 1\n        if substrings > k:\n            return 0\n        if index >= len(s):\n            return 0\n        if (index, substrings, nonprime_length) in memo:\n            return memo[(index, substrings, nonprime_length)]\n\n        result = dp(index + minLength, substrings + 1, 0)\n        for i in range(index + minLength, len(s)):\n            if isPrime(s[index]) and not isPrime(s[i]) and i - index + 1 >= minLength:\n                result += dp(i + 1, substrings + 1, nonprime_length + i - index + 1)\n                result %= MOD\n        memo[(index, substrings, nonprime_length)] = result\n        return result\n\n    return dp(0, 0, 0)\n```"}
{"task_id": "LeetCode-Hard/12", "completion": "\ndef rootCount(edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\n    n = len(edges) + 1\n    adj = defaultdict(list)\n    for a, b in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    indegrees = [0] * n\n    for u, v in guesses:\n        indegrees[v] += 1\n    queue = [u for u, v in guesses if indegrees[v] < k]\n    possible_roots = set(range(n))\n    while queue:\n        node = queue.pop(0)\n        possible_roots.remove(node)\n        for neighbor in adj[node]:\n            indegrees[neighbor] -= 1\n            if indegrees[neighbor] == k - 1:\n                queue.append(neighbor)\n    return len(possible_roots)\n", "raw_completion": "```python\ndef rootCount(edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\n    n = len(edges) + 1\n    adj = defaultdict(list)\n    for a, b in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    indegrees = [0] * n\n    for u, v in guesses:\n        indegrees[v] += 1\n    queue = [u for u, v in guesses if indegrees[v] < k]\n    possible_roots = set(range(n))\n    while queue:\n        node = queue.pop(0)\n        possible_roots.remove(node)\n        for neighbor in adj[node]:\n            indegrees[neighbor] -= 1\n            if indegrees[neighbor] == k - 1:\n                queue.append(neighbor)\n    return len(possible_roots)\n```"}
{"task_id": "LeetCode-Hard/36", "completion": "\ndef minCost(nums: List[int], cost: List[int]) -> int:\n    total_cost = 0\n    n = len(nums)\n    for i in range(1, n):\n        if nums[i] > nums[i-1]: continue\n        j = i\n        while j > 0 and nums[j] <= nums[j-1]:\n            total_cost += cost[j-1]\n            j -= 1\n        if j != i:\n            total_cost += min(cost[k] for k in range(j, i))\n            nums[j:i] = [nums[j]] * (i-j)\n    return total_cost\n", "raw_completion": "```python\ndef minCost(nums: List[int], cost: List[int]) -> int:\n    total_cost = 0\n    n = len(nums)\n    for i in range(1, n):\n        if nums[i] > nums[i-1]: continue\n        j = i\n        while j > 0 and nums[j] <= nums[j-1]:\n            total_cost += cost[j-1]\n            j -= 1\n        if j != i:\n            total_cost += min(cost[k] for k in range(j, i))\n            nums[j:i] = [nums[j]] * (i-j)\n    return total_cost\n```"}
{"task_id": "LeetCode-Hard/15", "completion": "\ndef findCrossingTime(n: int, k: int, time: List[List[int]]) -> int:\n    left, right = [], []\n    for i, (l, p, r, q) in enumerate(time):\n        left.append((l + p, r + q, i))\n    left.sort()\n    time_left = left.pop()\n    result = time_left[0]\n    n -= 1\n    while n:\n        while left and time_left[0] + max(time_left[1], left[-1][0]) >= left[-1][1]:\n            time_left = left.pop()\n        if not right or (left and right[0][0] > time_left[0] + max(time_left[1], left[-1][0])):\n            time_left, right = right[0] if right else time_left, []\n            heapq.heappush(right, (time_left[0] + time_left[1], time_left[2]))\n            result = time_left[0] + time_left[1]\n            n -= 1\n        else:\n            _, _, i = heapq.heappop(right)\n            result = right[0][0] if right else left[-1][1]\n            heapq.heappush(right, (result + time[i][2] + time[i][3], i))\n    return result\n", "raw_completion": "```python\ndef findCrossingTime(n: int, k: int, time: List[List[int]]) -> int:\n    left, right = [], []\n    for i, (l, p, r, q) in enumerate(time):\n        left.append((l + p, r + q, i))\n    left.sort()\n    time_left = left.pop()\n    result = time_left[0]\n    n -= 1\n    while n:\n        while left and time_left[0] + max(time_left[1], left[-1][0]) >= left[-1][1]:\n            time_left = left.pop()\n        if not right or (left and right[0][0] > time_left[0] + max(time_left[1], left[-1][0])):\n            time_left, right = right[0] if right else time_left, []\n            heapq.heappush(right, (time_left[0] + time_left[1], time_left[2]))\n            result = time_left[0] + time_left[1]\n            n -= 1\n        else:\n            _, _, i = heapq.heappop(right)\n            result = right[0][0] if right else left[-1][1]\n            heapq.heappush(right, (result + time[i][2] + time[i][3], i))\n    return result\n```"}
{"task_id": "LeetCode-Hard/27", "completion": "\ndef countPalindromes(s: str) -> int:\n    l = len(s)\n    if l < 5:\n        return 0\n    dp = [[0 for i in range(l)] for j in range(l)]\n    for i in range(l):\n        dp[i][i] = 1\n    for k in range(1, 5):\n        for i in range(l - k):\n            j = i + k\n            if s[i] == s[j]:\n                left = i + 1\n                right = j - 1\n                while left <= right and s[left] != s[j]:\n                    left += 1\n                while left <= right and s[right] != s[j]:\n                    right -= 1\n                if left > right:\n                    dp[i][j] = (dp[i+1][j-1] * 2 + 2) % (10**9 + 7)\n                elif left == right:\n                    dp[i][j] = (dp[i+1][j-1] * 2 + 1) % (10**9 + 7)\n                else:\n                    dp[i][j] = (dp[i+1][j-1] * 2 - dp[left + 1][right - 1]) % (10**9 + 7)\n            else:\n                dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]\n                dp[i][j] %= (10**9 + 7)\n    return dp[0][l-1]\n", "raw_completion": "```python\ndef countPalindromes(s: str) -> int:\n    l = len(s)\n    if l < 5:\n        return 0\n    dp = [[0 for i in range(l)] for j in range(l)]\n    for i in range(l):\n        dp[i][i] = 1\n    for k in range(1, 5):\n        for i in range(l - k):\n            j = i + k\n            if s[i] == s[j]:\n                left = i + 1\n                right = j - 1\n                while left <= right and s[left] != s[j]:\n                    left += 1\n                while left <= right and s[right] != s[j]:\n                    right -= 1\n                if left > right:\n                    dp[i][j] = (dp[i+1][j-1] * 2 + 2) % (10**9 + 7)\n                elif left == right:\n                    dp[i][j] = (dp[i+1][j-1] * 2 + 1) % (10**9 + 7)\n                else:\n                    dp[i][j] = (dp[i+1][j-1] * 2 - dp[left + 1][right - 1]) % (10**9 + 7)\n            else:\n                dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]\n                dp[i][j] %= (10**9 + 7)\n    return dp[0][l-1]\n```"}
{"task_id": "LeetCode-Hard/11", "completion": "\nfrom typing import List\n\ndef findMinimumTime(tasks: List[List[int]]) -> int:\n    min_start = float(\"inf\")\n    max_end = float(\"-inf\")\n    for start, end, duration in tasks:\n        min_start = min(min_start, start)\n        max_end = max(max_end, end)\n    duration = max_end - min_start + 1\n    tasks_start = [0] * duration\n    for start, end, duration in tasks:\n        for i in range(start - min_start, end - min_start + 1):\n            tasks_start[i] += duration\n    return max(tasks_start)\n", "raw_completion": "```python\nfrom typing import List\n\ndef findMinimumTime(tasks: List[List[int]]) -> int:\n    min_start = float(\"inf\")\n    max_end = float(\"-inf\")\n    for start, end, duration in tasks:\n        min_start = min(min_start, start)\n        max_end = max(max_end, end)\n    duration = max_end - min_start + 1\n    tasks_start = [0] * duration\n    for start, end, duration in tasks:\n        for i in range(start - min_start, end - min_start + 1):\n            tasks_start[i] += duration\n    return max(tasks_start)\n```"}
{"task_id": "LeetCode-Hard/21", "completion": "\nfrom itertools import combinations\n\ndef countPartitions(nums: List[int], k: int) -> int:\n    N = len(nums)\n    res = 0\n    mod = 10**9 + 7\n    for i in range(1, N+1):\n        for C in combinations(range(N), i):\n            l = [x for j, x in enumerate(nums) if j not in C]\n            r = [nums[j] for j in C]\n            if sum(l) >= k and sum(r) >= k:\n                res += 2**(N-i)\n                res %= mod\n    return res\n", "raw_completion": "```python\nfrom itertools import combinations\n\ndef countPartitions(nums: List[int], k: int) -> int:\n    N = len(nums)\n    res = 0\n    mod = 10**9 + 7\n    for i in range(1, N+1):\n        for C in combinations(range(N), i):\n            l = [x for j, x in enumerate(nums) if j not in C]\n            r = [nums[j] for j in C]\n            if sum(l) >= k and sum(r) >= k:\n                res += 2**(N-i)\n                res %= mod\n    return res\n```"}
{"task_id": "LeetCode-Hard/7", "completion": "\ndef minCost(basket1: List[int], basket2: List[int]) -> int:\n    total_cost = 0\n    sum1, sum2 = sum(basket1), sum(basket2)\n    if sum1 != sum2:\n        return -1\n    basket1.sort()\n    basket2.sort()\n    n = len(basket1)\n    i, j = 0, 0\n    while i < n and j < n:\n        if basket1[i] == basket2[j]:\n            i += 1\n            j += 1\n        elif basket1[i] < basket2[j]:\n            total_cost += basket1[i]\n            sum1 += basket2[j] - basket1[i]\n            i += 1\n        else:\n            total_cost += basket2[j]\n            sum2 += basket1[i] - basket2[j]\n            j += 1\n    return total_cost\n", "raw_completion": "```python\ndef minCost(basket1: List[int], basket2: List[int]) -> int:\n    total_cost = 0\n    sum1, sum2 = sum(basket1), sum(basket2)\n    if sum1 != sum2:\n        return -1\n    basket1.sort()\n    basket2.sort()\n    n = len(basket1)\n    i, j = 0, 0\n    while i < n and j < n:\n        if basket1[i] == basket2[j]:\n            i += 1\n            j += 1\n        elif basket1[i] < basket2[j]:\n            total_cost += basket1[i]\n            sum1 += basket2[j] - basket1[i]\n            i += 1\n        else:\n            total_cost += basket2[j]\n            sum2 += basket1[i] - basket2[j]\n            j += 1\n    return total_cost\n```"}
{"task_id": "LeetCode-Hard/5", "completion": "\ndef minimumScore(s: str, t: str) -> int:\n    def is_subsequence(x: str, y: str) -> bool:\n        it = iter(y)\n        return all(c in it for c in x)\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = dp[i-1][j]\n            if dp[i][j-1] < dp[i-1][j]:\n                dp[i][j] = dp[i][j-1] + 1\n            if s[i-1] == t[j-1]:\n                if dp[i-1][j-1] < dp[i][j]:\n                    dp[i][j] = dp[i-1][j-1]\n    left, right = -1, -1\n    for j in range(1, n + 1):\n        if dp[m][j] == 0: # \"dp[m][j] == 0\" means that \"t[:j]\" is a subsequence of s.\n            right = j\n            if left == -1: left = j\n    return right - left + 1\n", "raw_completion": "```python\ndef minimumScore(s: str, t: str) -> int:\n    def is_subsequence(x: str, y: str) -> bool:\n        it = iter(y)\n        return all(c in it for c in x)\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = dp[i-1][j]\n            if dp[i][j-1] < dp[i-1][j]:\n                dp[i][j] = dp[i][j-1] + 1\n            if s[i-1] == t[j-1]:\n                if dp[i-1][j-1] < dp[i][j]:\n                    dp[i][j] = dp[i-1][j-1]\n    left, right = -1, -1\n    for j in range(1, n + 1):\n        if dp[m][j] == 0: # \"dp[m][j] == 0\" means that \"t[:j]\" is a subsequence of s.\n            right = j\n            if left == -1: left = j\n    return right - left + 1\n```"}
{"task_id": "LeetCode-Hard/10", "completion": "\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef findShortestCycle(n: int, edges: List[List[int]]) -> int:\n    graph = defaultdict(set)\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    def bfs(start):\n        path_len = {start: 0}\n        q = deque([start])\n        while q:\n            node = q.popleft()\n            for neighbour in graph[node]:\n                if neighbour == start:\n                    return path_len[node] + 1\n                elif neighbour not in path_len:\n                    path_len[neighbour] = path_len[node] + 1\n                    q.append(neighbour)\n        return -1\n\n    shortest_cycle = float('inf')\n    for start in range(n):\n        cycle_len = bfs(start)\n        if cycle_len > 0:\n            shortest_cycle = min(shortest_cycle, cycle_len)\n\n    return shortest_cycle if shortest_cycle != float('inf') else -1\n", "raw_completion": "```python\nfrom collections import defaultdict, deque\nfrom typing import List\n\ndef findShortestCycle(n: int, edges: List[List[int]]) -> int:\n    graph = defaultdict(set)\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    def bfs(start):\n        path_len = {start: 0}\n        q = deque([start])\n        while q:\n            node = q.popleft()\n            for neighbour in graph[node]:\n                if neighbour == start:\n                    return path_len[node] + 1\n                elif neighbour not in path_len:\n                    path_len[neighbour] = path_len[node] + 1\n                    q.append(neighbour)\n        return -1\n\n    shortest_cycle = float('inf')\n    for start in range(n):\n        cycle_len = bfs(start)\n        if cycle_len > 0:\n            shortest_cycle = min(shortest_cycle, cycle_len)\n\n    return shortest_cycle if shortest_cycle != float('inf') else -1\n```"}
{"task_id": "LeetCode-Hard/14", "completion": "\ndef findValidSplit(nums: List[int]) -> int:\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n     \n    n = len(nums)\n    prefix = list(range(n))\n    suffix = [-1] * n\n    \n    prod = 1\n    for i in range(n):\n        prod *= nums[i]\n        if i == 0:\n            prefix[i] = nums[i]\n        else:\n            prefix[i] = gcd(prefix[i-1], nums[i])\n    \n    prod = 1\n    for i in range(n-1, -1, -1):\n        prod *= nums[i]\n        if i == n-1:\n            suffix[i] = nums[i]\n        else:\n            suffix[i] = gcd(suffix[i+1], nums[i])\n    \n    for i in range(n-1):\n        if gcd(prefix[i], suffix[i+1]) == 1:\n            return i\n    return -1\n", "raw_completion": "```python\ndef findValidSplit(nums: List[int]) -> int:\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n     \n    n = len(nums)\n    prefix = list(range(n))\n    suffix = [-1] * n\n    \n    prod = 1\n    for i in range(n):\n        prod *= nums[i]\n        if i == 0:\n            prefix[i] = nums[i]\n        else:\n            prefix[i] = gcd(prefix[i-1], nums[i])\n    \n    prod = 1\n    for i in range(n-1, -1, -1):\n        prod *= nums[i]\n        if i == n-1:\n            suffix[i] = nums[i]\n        else:\n            suffix[i] = gcd(suffix[i+1], nums[i])\n    \n    for i in range(n-1):\n        if gcd(prefix[i], suffix[i+1]) == 1:\n            return i\n    return -1\n```"}
{"task_id": "LeetCode-Hard/38", "completion": "\ndef countSubarrays(nums: List[int], minK: int, maxK: int) -> int:\n    res = 0\n    i = j = 0\n    n = len(nums)\n    while i < n:\n        while i < n and nums[i] != minK:\n            i += 1\n        if i == n:\n            return res\n        j = i\n        while j < n and nums[j] != maxK:\n            j += 1\n        res += (j - i + 1) * (j - i) // 2\n        i = j + 1\n    return res\n", "raw_completion": "```python\ndef countSubarrays(nums: List[int], minK: int, maxK: int) -> int:\n    res = 0\n    i = j = 0\n    n = len(nums)\n    while i < n:\n        while i < n and nums[i] != minK:\n            i += 1\n        if i == n:\n            return res\n        j = i\n        while j < n and nums[j] != maxK:\n            j += 1\n        res += (j - i + 1) * (j - i) // 2\n        i = j + 1\n    return res\n```"}
{"task_id": "LeetCode-Hard/23", "completion": "\ndef isPossible(n: int, edges: List[List[int]]) -> bool:\n    if n <= 0:\n        return False\n    if not edges:\n        return n % 2 == 0\n    degree_count = [0] * n\n    for edge in edges:\n        degree_count[edge[0]-1] += 1\n        degree_count[edge[1]-1] += 1\n    num_odd_degrees = sum([1 for d in degree_count if d % 2 == 1])\n    if num_odd_degrees <= 2 and ((n - num_odd_degrees) % 2 == 0):\n        return True\n    return False\n", "raw_completion": "```python\ndef isPossible(n: int, edges: List[List[int]]) -> bool:\n    if n <= 0:\n        return False\n    if not edges:\n        return n % 2 == 0\n    degree_count = [0] * n\n    for edge in edges:\n        degree_count[edge[0]-1] += 1\n        degree_count[edge[1]-1] += 1\n    num_odd_degrees = sum([1 for d in degree_count if d % 2 == 1])\n    if num_odd_degrees <= 2 and ((n - num_odd_degrees) % 2 == 0):\n        return True\n    return False\n```"}
{"task_id": "LeetCode-Hard/34", "completion": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom typing import List, Optional\n\nclass Solution:\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        \n        def dfs(root, q, height, res):\n            if not root:\n                return \n            if root.val in q:\n                return \n            if not root.left and not root.right:\n                res.append(height)\n                return \n            dfs(root.left, q, height+1, res)\n            dfs(root.right, q, height+1, res)\n        \n        res = []\n        for i in range(len(queries)):\n            dfs(root, [queries[i]], 0, res)\n            queries[i] = res[-1]\n            res.pop()\n        return queries\n", "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom typing import List, Optional\n\nclass Solution:\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\n        \n        def dfs(root, q, height, res):\n            if not root:\n                return \n            if root.val in q:\n                return \n            if not root.left and not root.right:\n                res.append(height)\n                return \n            dfs(root.left, q, height+1, res)\n            dfs(root.right, q, height+1, res)\n        \n        res = []\n        for i in range(len(queries)):\n            dfs(root, [queries[i]], 0, res)\n            queries[i] = res[-1]\n            res.pop()\n        return queries\n```"}
{"task_id": "LeetCode-Hard/40", "completion": "\ndef numberOfPaths(grid: List[List[int]], k: int) -> int:\n    mod = 10**9 + 7\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0] % k == 0\n    for i in range(1, m):\n        dp[i][0] = (dp[i - 1][0] and grid[i][0] % k == 0)\n    for j in range(1, n):\n        dp[0][j] = (dp[0][j - 1] and grid[0][j] % k == 0)\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = ((dp[i - 1][j] or dp[i][j - 1]) and ((dp[i - 1][j] + dp[i][j - 1] + grid[i][j]) % k == 0))\n    return dp[m - 1][n - 1] % mod\n", "raw_completion": "```python\ndef numberOfPaths(grid: List[List[int]], k: int) -> int:\n    mod = 10**9 + 7\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0] % k == 0\n    for i in range(1, m):\n        dp[i][0] = (dp[i - 1][0] and grid[i][0] % k == 0)\n    for j in range(1, n):\n        dp[0][j] = (dp[0][j - 1] and grid[0][j] % k == 0)\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = ((dp[i - 1][j] or dp[i][j - 1]) and ((dp[i - 1][j] + dp[i][j - 1] + grid[i][j]) % k == 0))\n    return dp[m - 1][n - 1] % mod\n```"}
{"task_id": "LeetCode-Hard/35", "completion": "\ndef makeSimilar(nums: List[int], target: List[int]) -> int:\n    diff = 0\n    for i in range(len(nums)):\n        diff += abs(nums[i]-target[i])\n    return diff//4\n", "raw_completion": "```python\ndef makeSimilar(nums: List[int], target: List[int]) -> int:\n    diff = 0\n    for i in range(len(nums)):\n        diff += abs(nums[i]-target[i])\n    return diff//4\n```"}
{"task_id": "LeetCode-Hard/33", "completion": "\ndef secondGreaterElement(nums: List[int]) -> List[int]:\n    n = len(nums)\n    stack, res = [], [-1] * n\n    for i in range(n - 1, -1, -1):\n        while stack and nums[i] >= stack[-1]:\n            stack.pop()\n        if stack:\n            res[i] = stack[-1]\n        stack.append(nums[i])\n        while len(stack) > 2:\n            stack.pop(0)\n    return res \n", "raw_completion": "```python\ndef secondGreaterElement(nums: List[int]) -> List[int]:\n    n = len(nums)\n    stack, res = [], [-1] * n\n    for i in range(n - 1, -1, -1):\n        while stack and nums[i] >= stack[-1]:\n            stack.pop()\n        if stack:\n            res[i] = stack[-1]\n        stack.append(nums[i])\n        while len(stack) > 2:\n            stack.pop(0)\n    return res \n```"}
{"task_id": "LeetCode-Hard/39", "completion": "\ndef lengthOfLIS(nums: List[int], k: int) -> int:\n    n = len(nums)\n    dp = [1] * n\n    res = 1\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] - nums[j] <= k:\n                dp[i] = max(dp[i], dp[j] + 1)\n        res = max(res, dp[i])\n    return res\n", "raw_completion": "```python\ndef lengthOfLIS(nums: List[int], k: int) -> int:\n    n = len(nums)\n    dp = [1] * n\n    res = 1\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] - nums[j] <= k:\n                dp[i] = max(dp[i], dp[j] + 1)\n        res = max(res, dp[i])\n    return res\n```"}
{"task_id": "LeetCode-Hard/9", "completion": "\nfrom typing import List\n\ndef putMarbles(weights: List[int], k: int) -> int:\n    n = len(weights)\n    left = max(weights)\n    right = sum(weights)\n    while left < right:\n        mid = (left + right) // 2\n        count = 1\n        cur_sum = 0\n        for weight in weights:\n            if cur_sum + weight > mid:\n                count += 1\n                cur_sum = weight\n            else:\n                cur_sum += weight\n        if count > k:\n            left = mid + 1\n        else:\n            right = mid\n    min_cost = left\n    pre_sum = 0\n    for i in range(n):\n        if pre_sum + weights[i] > min_cost or n - i == k:\n            pre_sum = 0\n            k -= 1\n        pre_sum +=  weights[i]\n    max_cost = pre_sum\n    return max_cost - min_cost\n", "raw_completion": "```python\nfrom typing import List\n\ndef putMarbles(weights: List[int], k: int) -> int:\n    n = len(weights)\n    left = max(weights)\n    right = sum(weights)\n    while left < right:\n        mid = (left + right) // 2\n        count = 1\n        cur_sum = 0\n        for weight in weights:\n            if cur_sum + weight > mid:\n                count += 1\n                cur_sum = weight\n            else:\n                cur_sum += weight\n        if count > k:\n            left = mid + 1\n        else:\n            right = mid\n    min_cost = left\n    pre_sum = 0\n    for i in range(n):\n        if pre_sum + weights[i] > min_cost or n - i == k:\n            pre_sum = 0\n            k -= 1\n        pre_sum +=  weights[i]\n    max_cost = pre_sum\n    return max_cost - min_cost\n```"}
{"task_id": "LeetCode-Hard/4", "completion": "\nfrom typing import List\n\ndef handleQuery(nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n    res = []\n    for query in queries:\n        if query[0] == 1:\n            for i in range(query[1], query[2] + 1):\n                nums1[i] = 1 - nums1[i]\n        elif query[0] == 2:\n            res.append(0)\n            for i in range(len(nums2)):\n                res[-1] += nums1[i] * query[1]\n                nums2[i] += nums1[i] * query[1]\n        else:\n            res.append(sum(nums2))\n    return res\n", "raw_completion": "```python\nfrom typing import List\n\ndef handleQuery(nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n    res = []\n    for query in queries:\n        if query[0] == 1:\n            for i in range(query[1], query[2] + 1):\n                nums1[i] = 1 - nums1[i]\n        elif query[0] == 2:\n            res.append(0)\n            for i in range(len(nums2)):\n                res[-1] += nums1[i] * query[1]\n                nums2[i] += nums1[i] * query[1]\n        else:\n            res.append(sum(nums2))\n    return res\n```"}
{"task_id": "LeetCode-Hard/6", "completion": "\ndef minimumVisitedCells(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    queue = [(0, 0)]\n    visited = {(0, 0)}\n    steps = 0\n    \n    while queue:\n        for _ in range(len(queue)):\n            i, j = queue.pop(0)\n            if i == m - 1 and j == n - 1:\n                return steps + 1\n            for ni in range(i + 1, min(m, i + grid[i][j] + 1)):\n                if (ni, j) not in visited:\n                    visited.add((ni, j))\n                    queue.append((ni, j))\n            for nj in range(j + 1, min(n, j + grid[i][j] + 1)):\n                if (i, nj) not in visited:\n                    visited.add((i, nj))\n                    queue.append((i, nj))\n        steps += 1\n    \n    return -1\n", "raw_completion": "```python\ndef minimumVisitedCells(grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    queue = [(0, 0)]\n    visited = {(0, 0)}\n    steps = 0\n    \n    while queue:\n        for _ in range(len(queue)):\n            i, j = queue.pop(0)\n            if i == m - 1 and j == n - 1:\n                return steps + 1\n            for ni in range(i + 1, min(m, i + grid[i][j] + 1)):\n                if (ni, j) not in visited:\n                    visited.add((ni, j))\n                    queue.append((ni, j))\n            for nj in range(j + 1, min(n, j + grid[i][j] + 1)):\n                if (i, nj) not in visited:\n                    visited.add((i, nj))\n                    queue.append((i, nj))\n        steps += 1\n    \n    return -1\n```"}
{"task_id": "LeetCode-Hard/28", "completion": "\nfrom typing import List\n\ndef countSubarrays(nums: List[int], k: int) -> int:\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i, n):\n            sub_array = nums[i:j+1]\n            sub_array.sort()\n            len_s = len(sub_array)\n            if len_s % 2 == 0:\n                m = sub_array[len_s//2 - 1]\n            else:\n                m = sub_array[len_s//2]\n            if m == k:\n                count += 1\n    return count\n", "raw_completion": "```python\nfrom typing import List\n\ndef countSubarrays(nums: List[int], k: int) -> int:\n    count = 0\n    n = len(nums)\n    for i in range(n):\n        for j in range(i, n):\n            sub_array = nums[i:j+1]\n            sub_array.sort()\n            len_s = len(sub_array)\n            if len_s % 2 == 0:\n                m = sub_array[len_s//2 - 1]\n            else:\n                m = sub_array[len_s//2]\n            if m == k:\n                count += 1\n    return count\n```"}
{"task_id": "LeetCode-Hard/18", "completion": "\nfrom typing import List\nfrom collections import defaultdict\n\ndef dfs(node, parent, price, total_price, max_weight, min_weight):\n    total_price[node] = price[node]\n    for child in adj_list[node]:\n        if child != parent:\n            dfs(child, node, price, total_price, max_weight, min_weight)\n            total_price[node] += total_price[child]\n            max_weight[node] = max(max_weight[node], max_weight[child] - total_price[child])\n            min_weight[node] = min(min_weight[node], min_weight[child] + total_price[child])\n\ndef maxOutput(n: int, edges: List[List[int]], price: List[int]) -> int:\n    adj_list = defaultdict(list)\n    for edge in edges:\n        adj_list[edge[0]].append(edge[1])\n        adj_list[edge[1]].append(edge[0])\n    total_price = [0] * n\n    max_weight = [float('-inf')] * n\n    min_weight = [float('inf')] * n\n    dfs(0, -1, price, total_price, max_weight, min_weight)\n    ans = float('-inf')\n    for i in range(n):\n        ans = max(ans, max_weight[i] + total_price[i] - min_weight[i])\n    return ans\n", "raw_completion": "```python\nfrom typing import List\nfrom collections import defaultdict\n\ndef dfs(node, parent, price, total_price, max_weight, min_weight):\n    total_price[node] = price[node]\n    for child in adj_list[node]:\n        if child != parent:\n            dfs(child, node, price, total_price, max_weight, min_weight)\n            total_price[node] += total_price[child]\n            max_weight[node] = max(max_weight[node], max_weight[child] - total_price[child])\n            min_weight[node] = min(min_weight[node], min_weight[child] + total_price[child])\n\ndef maxOutput(n: int, edges: List[List[int]], price: List[int]) -> int:\n    adj_list = defaultdict(list)\n    for edge in edges:\n        adj_list[edge[0]].append(edge[1])\n        adj_list[edge[1]].append(edge[0])\n    total_price = [0] * n\n    max_weight = [float('-inf')] * n\n    min_weight = [float('inf')] * n\n    dfs(0, -1, price, total_price, max_weight, min_weight)\n    ans = float('-inf')\n    for i in range(n):\n        ans = max(ans, max_weight[i] + total_price[i] - min_weight[i])\n    return ans\n```"}
{"task_id": "LeetCode-Hard/22", "completion": "\nfrom typing import List\n\ndef cycleLengthQueries(n: int, queries: List[List[int]]) -> List[int]:\n    # initialize the tree with all nodes connected to their children\n    tree = [[] for _ in range(2*n)]\n    for i in range(1, n):\n        tree[i].extend([2*i, 2*i+1])\n        tree[2*i].append(i)\n        tree[2*i+1].append(i)\n    # function to find a cycle length using DFS\n    def find_cycle(start, parent, curr, visited, depth):\n        visited[curr] = True\n        for neighbor in tree[curr]:\n            if neighbor == parent:\n                continue\n            if neighbor == start:\n                return depth+1\n            if visited[neighbor]:\n                continue\n            len_cycle = find_cycle(start, curr, neighbor, visited, depth+1)\n            if len_cycle is not None:\n                return len_cycle\n        return None\n    # solve queries one by one\n    ans = []\n    for query in queries:\n        a, b = query\n        tree[a].append(b)\n        tree[b].append(a)\n        visited = [False] * (2*n)\n        len_cycle = find_cycle(a, -1, b, visited, 0)\n        ans.append(len_cycle)\n        tree[a].remove(b)\n        tree[b].remove(a)\n    return ans\n", "raw_completion": "```python\nfrom typing import List\n\ndef cycleLengthQueries(n: int, queries: List[List[int]]) -> List[int]:\n    # initialize the tree with all nodes connected to their children\n    tree = [[] for _ in range(2*n)]\n    for i in range(1, n):\n        tree[i].extend([2*i, 2*i+1])\n        tree[2*i].append(i)\n        tree[2*i+1].append(i)\n    # function to find a cycle length using DFS\n    def find_cycle(start, parent, curr, visited, depth):\n        visited[curr] = True\n        for neighbor in tree[curr]:\n            if neighbor == parent:\n                continue\n            if neighbor == start:\n                return depth+1\n            if visited[neighbor]:\n                continue\n            len_cycle = find_cycle(start, curr, neighbor, visited, depth+1)\n            if len_cycle is not None:\n                return len_cycle\n        return None\n    # solve queries one by one\n    ans = []\n    for query in queries:\n        a, b = query\n        tree[a].append(b)\n        tree[b].append(a)\n        visited = [False] * (2*n)\n        len_cycle = find_cycle(a, -1, b, visited, 0)\n        ans.append(len_cycle)\n        tree[a].remove(b)\n        tree[b].remove(a)\n    return ans\n```"}
{"task_id": "LeetCode-Hard/19", "completion": "\nfrom typing import List\n\ndef maxPower(stations: List[int], r: int, k: int) -> int:\n    n = len(stations)\n    left, right = 0, max(stations) + k\n    while left < right:\n        mid = (left + right + 1) // 2\n        new_stations = list(stations)\n        cnt = k\n        for i in range(n):\n            if new_stations[i] < mid:\n                need = mid - new_stations[i]\n                if cnt < need:\n                    break\n                cnt -= need\n                for j in range(max(0, i - r), min(n, i + r + 1)):\n                    new_stations[j] += need\n        else:\n            left = mid\n            stations = new_stations\n        right = mid - 1\n    return left\n", "raw_completion": "```python\nfrom typing import List\n\ndef maxPower(stations: List[int], r: int, k: int) -> int:\n    n = len(stations)\n    left, right = 0, max(stations) + k\n    while left < right:\n        mid = (left + right + 1) // 2\n        new_stations = list(stations)\n        cnt = k\n        for i in range(n):\n            if new_stations[i] < mid:\n                need = mid - new_stations[i]\n                if cnt < need:\n                    break\n                cnt -= need\n                for j in range(max(0, i - r), min(n, i + r + 1)):\n                    new_stations[j] += need\n        else:\n            left = mid\n            stations = new_stations\n        right = mid - 1\n    return left\n```"}
{"task_id": "LeetCode-Hard/25", "completion": "\ndef maxPoints(grid: List[List[int]], queries: List[int]) -> List[int]:\n    answer = []\n    for q in queries:\n        points = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] >= q:\n                    continue\n                if i > 0 and grid[i-1][j] < q:\n                    continue\n                if j > 0 and grid[i][j-1] < q:\n                    continue\n                if i < len(grid)-1 and grid[i+1][j] < q:\n                    continue\n                if j < len(grid[0])-1 and grid[i][j+1] < q:\n                    continue\n                points += 1\n        answer.append(points)\n    return answer\n", "raw_completion": "```python\ndef maxPoints(grid: List[List[int]], queries: List[int]) -> List[int]:\n    answer = []\n    for q in queries:\n        points = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] >= q:\n                    continue\n                if i > 0 and grid[i-1][j] < q:\n                    continue\n                if j > 0 and grid[i][j-1] < q:\n                    continue\n                if i < len(grid)-1 and grid[i+1][j] < q:\n                    continue\n                if j < len(grid[0])-1 and grid[i][j+1] < q:\n                    continue\n                points += 1\n        answer.append(points)\n    return answer\n```"}
{"task_id": "LeetCode-Hard/26", "completion": "\nfrom queue import Queue\nfrom typing import List\n\ndef magnificentSets(n: int, edges: List[List[int]]) -> int:\n    groups = [-1] * (n+1)\n    q = Queue()\n    for node in range(1, n+1):\n        if groups[node] == -1:\n            groups[node] = 1\n            q.put(node)\n            while not q.empty():\n                curr = q.get()\n                for neighbor in get_neighbors(curr, edges):\n                    if groups[neighbor] == groups[curr]:\n                        return -1\n                    if groups[neighbor] == -1:\n                        groups[neighbor] = groups[curr] + 1\n                        q.put(neighbor)\n    return max(groups)\n\ndef get_neighbors(node: int, edges: List[List[int]]) -> List[int]:\n    neighbors = []\n    for edge in edges:\n        if node == edge[0]:\n            neighbors.append(edge[1])\n        elif node == edge[1]:\n            neighbors.append(edge[0])\n    return neighbors\n", "raw_completion": "```python\nfrom queue import Queue\nfrom typing import List\n\ndef magnificentSets(n: int, edges: List[List[int]]) -> int:\n    groups = [-1] * (n+1)\n    q = Queue()\n    for node in range(1, n+1):\n        if groups[node] == -1:\n            groups[node] = 1\n            q.put(node)\n            while not q.empty():\n                curr = q.get()\n                for neighbor in get_neighbors(curr, edges):\n                    if groups[neighbor] == groups[curr]:\n                        return -1\n                    if groups[neighbor] == -1:\n                        groups[neighbor] = groups[curr] + 1\n                        q.put(neighbor)\n    return max(groups)\n\ndef get_neighbors(node: int, edges: List[List[int]]) -> List[int]:\n    neighbors = []\n    for edge in edges:\n        if node == edge[0]:\n            neighbors.append(edge[1])\n        elif node == edge[1]:\n            neighbors.append(edge[0])\n    return neighbors\n```"}
{"task_id": "LeetCode-Hard/20", "completion": "\ndef countAnagrams(s: str) -> int:\n    from collections import Counter\n    words = s.split()\n    word_count = len(words)\n    counter_list = [Counter(word) for word in words]\n    counts = Counter([tuple(sorted(str(counter))) for counter in counter_list])\n    total = 1\n    for count in counts:\n        total *= counts[count]\n    return total % (10**9 + 7)\n", "raw_completion": "```python\ndef countAnagrams(s: str) -> int:\n    from collections import Counter\n    words = s.split()\n    word_count = len(words)\n    counter_list = [Counter(word) for word in words]\n    counts = Counter([tuple(sorted(str(counter))) for counter in counter_list])\n    total = 1\n    for count in counts:\n        total *= counts[count]\n    return total % (10**9 + 7)\n```"}
{"task_id": "LeetCode-Hard/1", "completion": "\ndef collectTheCoins(coins: List[int], edges: List[List[int]]) -> int:\n    from collections import deque\n\n    # Create a dictionary of vertices and their adjacent edges\n    adj_list = {i: set() for i in range(len(coins))}\n    for i, j in edges:\n        adj_list[i].add(j)\n        adj_list[j].add(i)\n\n    # Breadth First Search\n    def bfs(start, visited):\n        queue = deque([(start, 0)])\n        while queue:\n            u, n = queue.popleft()\n            for v in adj_list[u]:\n                if v not in visited:\n                    visited.add(v)\n                    queue.append((v, n + 1))\n        return n  # Number of edges traveled\n\n    # Find all coins\n    coin_pos = set(i for i in range(len(coins)) if coins[i] == 1)\n\n    # Check starting positions and find the min number of edges traveled to collect all coins\n    min_edges = float('inf')\n    for i in coin_pos:\n        visited = {i}\n        bfs(i, visited)\n        for j in coin_pos - visited:\n            bfs(j, visited)\n        if len(visited) == len(coin_pos):\n            min_edges = min(min_edges, bfs(i, visited) + bfs(j, visited))\n    return min_edges\n", "raw_completion": "```python\ndef collectTheCoins(coins: List[int], edges: List[List[int]]) -> int:\n    from collections import deque\n\n    # Create a dictionary of vertices and their adjacent edges\n    adj_list = {i: set() for i in range(len(coins))}\n    for i, j in edges:\n        adj_list[i].add(j)\n        adj_list[j].add(i)\n\n    # Breadth First Search\n    def bfs(start, visited):\n        queue = deque([(start, 0)])\n        while queue:\n            u, n = queue.popleft()\n            for v in adj_list[u]:\n                if v not in visited:\n                    visited.add(v)\n                    queue.append((v, n + 1))\n        return n  # Number of edges traveled\n\n    # Find all coins\n    coin_pos = set(i for i in range(len(coins)) if coins[i] == 1)\n\n    # Check starting positions and find the min number of edges traveled to collect all coins\n    min_edges = float('inf')\n    for i in coin_pos:\n        visited = {i}\n        bfs(i, visited)\n        for j in coin_pos - visited:\n            bfs(j, visited)\n        if len(visited) == len(coin_pos):\n            min_edges = min(min_edges, bfs(i, visited) + bfs(j, visited))\n    return min_edges\n```"}
{"task_id": "LeetCode-Hard/13", "completion": "\nfrom typing import List\n\ndef waysToReachTarget(target: int, types: List[List[int]]) -> int:\n    mod = 10**9 + 7\n    dp = [1] + [0] * target\n    for count, marks in types:\n        for j in range(marks, target + 1):\n            dp[j] += dp[j - marks] * count\n            dp[j] %= mod\n    return dp[-1]\n", "raw_completion": "```python\nfrom typing import List\n\ndef waysToReachTarget(target: int, types: List[List[int]]) -> int:\n    mod = 10**9 + 7\n    dp = [1] + [0] * target\n    for count, marks in types:\n        for j in range(marks, target + 1):\n            dp[j] += dp[j - marks] * count\n            dp[j] %= mod\n    return dp[-1]\n```"}
{"task_id": "LeetCode-Hard/17", "completion": "\nfrom collections import Counter\n\ndef minCost(nums: List[int], k: int) -> int:\n    n = len(nums)\n    res = float(\"inf\")\n    dp = [0] * (n + 1)\n    for l in range(1, n + 1):\n        cost_k = l * k\n        freq = Counter(nums[:l])\n        max_freq = max(freq.values())\n\n        new_trimmed = []\n        for num in nums[:l]:\n            if freq[num] > 1:\n                new_trimmed.append(num)\n        cost_trimmed = cost_k + (len(new_trimmed) - max_freq)\n\n        dp[l] = cost_trimmed\n        for r in range(2, l + 1):\n            cost_subarray = k + dp[l - r + 1 : l + 1]\n            dp[l] = min(dp[l], dp[l - r] + cost_subarray)\n\n    return dp[-1]\n", "raw_completion": "```python\nfrom collections import Counter\n\ndef minCost(nums: List[int], k: int) -> int:\n    n = len(nums)\n    res = float(\"inf\")\n    dp = [0] * (n + 1)\n    for l in range(1, n + 1):\n        cost_k = l * k\n        freq = Counter(nums[:l])\n        max_freq = max(freq.values())\n\n        new_trimmed = []\n        for num in nums[:l]:\n            if freq[num] > 1:\n                new_trimmed.append(num)\n        cost_trimmed = cost_k + (len(new_trimmed) - max_freq)\n\n        dp[l] = cost_trimmed\n        for r in range(2, l + 1):\n            cost_subarray = k + dp[l - r + 1 : l + 1]\n            dp[l] = min(dp[l], dp[l - r] + cost_subarray)\n\n    return dp[-1]\n```"}
{"task_id": "LeetCode-Hard/3", "completion": "\nfrom string import ascii_lowercase\nfrom typing import List\n\ndef findTheString(lcp: List[List[int]]) -> str:\n    n = len(lcp)\n    res = [\"\"]*n\n    for i in range(n):\n        c = ascii_lowercase\n        for j in range(i):\n            k = lcp[i][j]\n            if k == n-j:\n                return \"\"\n            if k == n-i:\n                c = c.replace(res[j][n-i-1], \"\")\n        res[i] = c[0]\n    return \"\".join(res)\n", "raw_completion": "```python\nfrom string import ascii_lowercase\nfrom typing import List\n\ndef findTheString(lcp: List[List[int]]) -> str:\n    n = len(lcp)\n    res = [\"\"]*n\n    for i in range(n):\n        c = ascii_lowercase\n        for j in range(i):\n            k = lcp[i][j]\n            if k == n-j:\n                return \"\"\n            if k == n-i:\n                c = c.replace(res[j][n-i-1], \"\")\n        res[i] = c[0]\n    return \"\".join(res)\n```"}
{"task_id": "LeetCode-Hard/37", "completion": "\nfrom collections import defaultdict\n\ndef componentValue(nums: List[int], edges: List[List[int]]) -> int:\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    def dfs(node, parent):\n        total_sum = nums[node]\n        count = 1\n        for nei in adj_list[node]:\n            if nei == parent:\n                continue\n            subtree_sum, subtree_count = dfs(nei, node)\n            total_sum += subtree_sum\n            count += subtree_count\n        weight, remainder = divmod(total_sum, count)\n        if remainder == 0:\n            subcomponent_sums.add(weight)\n        return total_sum, count\n\n    subcomponent_sums = set()\n    if len(edges) == 0:\n        return 0\n    dfs(0, -1)\n    if len(subcomponent_sums) == 1:\n        return len(edges)\n    elif sum(nums) % len(nums) != 0:\n        return 0\n    root_val = sum(nums) // len(nums)\n    max_deleted_edges = len(edges) - (len(subcomponent_sums) - 1)\n    for val in subcomponent_sums:\n        if root_val - val in subcomponent_sums:\n            max_deleted_edges += 1\n    return max_deleted_edges\n", "raw_completion": "```python\nfrom collections import defaultdict\n\ndef componentValue(nums: List[int], edges: List[List[int]]) -> int:\n    adj_list = defaultdict(list)\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    def dfs(node, parent):\n        total_sum = nums[node]\n        count = 1\n        for nei in adj_list[node]:\n            if nei == parent:\n                continue\n            subtree_sum, subtree_count = dfs(nei, node)\n            total_sum += subtree_sum\n            count += subtree_count\n        weight, remainder = divmod(total_sum, count)\n        if remainder == 0:\n            subcomponent_sums.add(weight)\n        return total_sum, count\n\n    subcomponent_sums = set()\n    if len(edges) == 0:\n        return 0\n    dfs(0, -1)\n    if len(subcomponent_sums) == 1:\n        return len(edges)\n    elif sum(nums) % len(nums) != 0:\n        return 0\n    root_val = sum(nums) // len(nums)\n    max_deleted_edges = len(edges) - (len(subcomponent_sums) - 1)\n    for val in subcomponent_sums:\n        if root_val - val in subcomponent_sums:\n            max_deleted_edges += 1\n    return max_deleted_edges\n```"}
{"task_id": "LeetCode-Hard/30", "completion": "\ndef splitMessage(message: str, limit: int) -> List[str]:\n    n = len(message)\n    b = (n + limit - 1) // limit\n    if b == 1:\n        return [message+\"<1/1>\"]\n    if n <= limit*b-2:\n        return []\n    w = []\n    for i in range(b):\n        if i == b-1:\n            s = message[limit*i:]\n        else:\n            s = message[limit*i:limit*(i+1)]\n        w.append(s+\"<\"+str(i+1)+\"/\"+str(b)+\">\")\n    return w\n", "raw_completion": "```python\ndef splitMessage(message: str, limit: int) -> List[str]:\n    n = len(message)\n    b = (n + limit - 1) // limit\n    if b == 1:\n        return [message+\"<1/1>\"]\n    if n <= limit*b-2:\n        return []\n    w = []\n    for i in range(b):\n        if i == b-1:\n            s = message[limit*i:]\n        else:\n            s = message[limit*i:limit*(i+1)]\n        w.append(s+\"<\"+str(i+1)+\"/\"+str(b)+\">\")\n    return w\n```"}
{"task_id": "LeetCode-Hard/31", "completion": "\ndef maxPalindromes(s: str, k: int) -> int:\n    def is_palindrome(str):\n        return str == str[::-1]\n    palindromes = set()\n    for i in range(len(s)):\n        for j in range(k, len(s)-i+1):\n            if is_palindrome(s[i:i+j]):\n                palindromes.add(s[i:i+j])\n    max_palindromes = 0\n    selected = set()\n    for palindrome in sorted(palindromes, key=len, reverse=True):\n        if not any(p in selected for p in palindromes if p != palindrome and palindrome in p):\n            max_palindromes += 1\n            selected.add(palindrome)\n    return max_palindromes\n", "raw_completion": "```python\ndef maxPalindromes(s: str, k: int) -> int:\n    def is_palindrome(str):\n        return str == str[::-1]\n    palindromes = set()\n    for i in range(len(s)):\n        for j in range(k, len(s)-i+1):\n            if is_palindrome(s[i:i+j]):\n                palindromes.add(s[i:i+j])\n    max_palindromes = 0\n    selected = set()\n    for palindrome in sorted(palindromes, key=len, reverse=True):\n        if not any(p in selected for p in palindromes if p != palindrome and palindrome in p):\n            max_palindromes += 1\n            selected.add(palindrome)\n    return max_palindromes\n```"}
{"task_id": "LeetCode-Hard/32", "completion": "\nfrom typing import List\ndef minimumTotalDistance(robot: List[int], factory: List[List[int]]) -> int:\n    robot.sort()\n    factory.sort()\n    x1, x2 = 0, len(robot)\n    ans = float('inf')\n    for x in factory:\n        left, right = [], []\n        while x1 < x2 and robot[x1] < x[0]:\n            left.append(robot[x1])\n            x1 += 1\n        while x1 < x2 and robot[x2-1] > x[0]:\n            right.append(robot[x2-1])\n            x2 -= 1\n        tmp = 0\n        for y in left:\n            tmp += abs(y - x[0])\n        for y in right:\n            tmp += abs(y - x[0])\n        tmp = min(tmp, x[1] * (left[-1] - x[0]) + x[1] * (x[0] - right[0]))\n        ans = min(ans, tmp)\n    return int(ans)\n", "raw_completion": "```python\nfrom typing import List\ndef minimumTotalDistance(robot: List[int], factory: List[List[int]]) -> int:\n    robot.sort()\n    factory.sort()\n    x1, x2 = 0, len(robot)\n    ans = float('inf')\n    for x in factory:\n        left, right = [], []\n        while x1 < x2 and robot[x1] < x[0]:\n            left.append(robot[x1])\n            x1 += 1\n        while x1 < x2 and robot[x2-1] > x[0]:\n            right.append(robot[x2-1])\n            x2 -= 1\n        tmp = 0\n        for y in left:\n            tmp += abs(y - x[0])\n        for y in right:\n            tmp += abs(y - x[0])\n        tmp = min(tmp, x[1] * (left[-1] - x[0]) + x[1] * (x[0] - right[0]))\n        ans = min(ans, tmp)\n    return int(ans)\n```"}
{"task_id": "LeetCode-Hard/16", "completion": "\ndef isReachable(targetX: int, targetY: int) -> bool:\n    x, y = 1, 1\n    if x > targetX or y > targetY:\n        return False\n    while x != targetX or y != targetY:\n        if x + y > targetY:\n            if x > targetX:\n                return False\n            y = x + y\n        else:\n            x = x + y\n        if x > targetX or y > targetY:\n            return False\n    return True\n", "raw_completion": "```python\ndef isReachable(targetX: int, targetY: int) -> bool:\n    x, y = 1, 1\n    if x > targetX or y > targetY:\n        return False\n    while x != targetX or y != targetY:\n        if x + y > targetY:\n            if x > targetX:\n                return False\n            y = x + y\n        else:\n            x = x + y\n        if x > targetX or y > targetY:\n            return False\n    return True\n```"}
{"task_id": "LeetCode-Hard/24", "completion": "\nfrom typing import List\n\ndef minimumTotalCost(nums1: List[int], nums2: List[int]) -> int:\n    diff = []\n    total_cost, dif_cost = 0, 0\n    for i in range(len(nums1)):\n        if nums1[i] != nums2[i]:\n            diff.append([nums1[i], nums2[i], i])\n    for i in range(len(diff)):\n        dif_cost = abs(diff[i][0] - diff[i][1])\n        total_cost += dif_cost + diff[i][2]\n    if not diff:\n        return 0\n    elif total_cost % 2 == 1:\n        return -1\n    else:\n        return total_cost // 2\n", "raw_completion": "```python\nfrom typing import List\n\ndef minimumTotalCost(nums1: List[int], nums2: List[int]) -> int:\n    diff = []\n    total_cost, dif_cost = 0, 0\n    for i in range(len(nums1)):\n        if nums1[i] != nums2[i]:\n            diff.append([nums1[i], nums2[i], i])\n    for i in range(len(diff)):\n        dif_cost = abs(diff[i][0] - diff[i][1])\n        total_cost += dif_cost + diff[i][2]\n    if not diff:\n        return 0\n    elif total_cost % 2 == 1:\n        return -1\n    else:\n        return total_cost // 2\n```"}
{"task_id": "LeetCode-Hard/8", "completion": "\ndef countQuadruplets(nums: List[int]) -> int:\n    res = 0\n    n = len(nums)\n    for i in range(n-3):\n        for j in range(i+1,n-2):\n            for k in range(j+1,n-1):\n                for l in range(k+1,n):\n                    if nums[i] < nums[k] < nums[j] < nums[l]:\n                        res += 1\n    return res\n", "raw_completion": "```python\ndef countQuadruplets(nums: List[int]) -> int:\n    res = 0\n    n = len(nums)\n    for i in range(n-3):\n        for j in range(i+1,n-2):\n            for k in range(j+1,n-1):\n                for l in range(k+1,n):\n                    if nums[i] < nums[k] < nums[j] < nums[l]:\n                        res += 1\n    return res\n```"}
{"task_id": "LeetCode-Hard/2", "completion": "\nfrom typing import List\n\n\ndef minimumTime(grid: List[List[int]]) -> int:\n    n, m = len(grid), len(grid[0])\n    # Initializing the start and end location\n    start, end = (0, 0), (n-1, m-1)\n    \n    visited = set()\n    visited.add(start)\n    queue = [(start, 0)]\n    \n    while queue:\n        node, time = queue.pop(0)\n        row, col = node\n        \n        #If we reach the end cell, return the minimum time\n        if node == end:\n            return time\n        \n        #Checking for the four directions of movement\n        for r, c in [[row-1, col], [row+1, col], [row, col-1], [row, col+1]]:\n            if 0 <= r < n and 0 <= c < m and (r, c) not in visited and time+1 >= grid[r][c]:\n                visited.add((r, c))\n                queue.append(((r, c),time+1))\n    return -1\n", "raw_completion": "```python\nfrom typing import List\n\n\ndef minimumTime(grid: List[List[int]]) -> int:\n    n, m = len(grid), len(grid[0])\n    # Initializing the start and end location\n    start, end = (0, 0), (n-1, m-1)\n    \n    visited = set()\n    visited.add(start)\n    queue = [(start, 0)]\n    \n    while queue:\n        node, time = queue.pop(0)\n        row, col = node\n        \n        #If we reach the end cell, return the minimum time\n        if node == end:\n            return time\n        \n        #Checking for the four directions of movement\n        for r, c in [[row-1, col], [row+1, col], [row, col-1], [row, col+1]]:\n            if 0 <= r < n and 0 <= c < m and (r, c) not in visited and time+1 >= grid[r][c]:\n                visited.add((r, c))\n                queue.append(((r, c),time+1))\n    return -1\n```"}