{"task_id": "LeetCode-Hard/0", "completion": "\ndef minReverseOperations(n: int, p: int, banned: List[int], k: int) -> List[int]:\n    ans = [-1] * n\n    ans[p] = 0\n    if k > 1:\n        for i in range(n):\n            if i not in banned and abs(p - i) % k == 0:\n                ans[i] = max(abs(p - i) // k - 1, 0) + abs(abs(p - i) // k - abs((p - i) % k))\n    return ans\n", "raw_completion": "```python\ndef minReverseOperations(n: int, p: int, banned: List[int], k: int) -> List[int]:\n    ans = [-1] * n\n    ans[p] = 0\n    if k > 1:\n        for i in range(n):\n            if i not in banned and abs(p - i) % k == 0:\n                ans[i] = max(abs(p - i) // k - 1, 0) + abs(abs(p - i) // k - abs((p - i) % k))\n    return ans\n```"}
{"task_id": "LeetCode-Hard/20", "completion": "\ndef countAnagrams(s: str) -> int:\n    from math import factorial\n    \n    words = s.split()\n    word_counts = [factorial(len(word)) for word in words]\n    anagram_count = 1\n    \n    for count in word_counts:\n        anagram_count *= count\n        \n    return anagram_count % (10**9 + 7)\n", "raw_completion": "```python\ndef countAnagrams(s: str) -> int:\n    from math import factorial\n    \n    words = s.split()\n    word_counts = [factorial(len(word)) for word in words]\n    anagram_count = 1\n    \n    for count in word_counts:\n        anagram_count *= count\n        \n    return anagram_count % (10**9 + 7)\n```"}
{"task_id": "LeetCode-Hard/15", "completion": "\ndef findCrossingTime(n: int, k: int, time: List[List[int]]) -> int:\n    workers_efficiency = sorted([(i, sum(time[i][0], time[i][2])) for i in range(k)], key=lambda x: (x[1], x[0]))\n    left = 0\n    right = []\n    events = []\n    total_boxes = n\n\n    while total_boxes:\n        if not right and total_boxes:\n            left += workers_efficiency[0][1]\n            events.append(((left, left + time[workers_efficiency[0][0]][1]), workers_efficiency[0][0]))\n            total_boxes -= 1\n            workers_efficiency.pop(0)\n        elif right and not total_boxes:\n            left += min(left - right[0][0][1], right[0][1])\n            break\n        else:\n            if left < right[0][0][1]:\n                left = right[0][0][1]\n            if left + workers_efficiency[0][1] < right[0][0][0]:\n                left += workers_efficiency[0][1]\n                events.append(((left, left + time[workers_efficiency[0][0]][1]), workers_efficiency[0][0]))\n                total_boxes -= 1\n                workers_efficiency.pop(0)\n\n            elif left + workers_efficiency[0][1] == right[0][0][0]:\n                left += workers_efficiency[0][1] * 2\n                events.append(((left, left + time[workers_efficiency[0][0]][1]), workers_efficiency[0][0]))\n                workers_efficiency.pop(0)\n                right = [x for x in right if x[0][1] > left]\n            else:\n                left += workers_efficiency[0][1]\n                right.pop(0)\n\n    return left\n", "raw_completion": "```python\ndef findCrossingTime(n: int, k: int, time: List[List[int]]) -> int:\n    workers_efficiency = sorted([(i, sum(time[i][0], time[i][2])) for i in range(k)], key=lambda x: (x[1], x[0]))\n    left = 0\n    right = []\n    events = []\n    total_boxes = n\n\n    while total_boxes:\n        if not right and total_boxes:\n            left += workers_efficiency[0][1]\n            events.append(((left, left + time[workers_efficiency[0][0]][1]), workers_efficiency[0][0]))\n            total_boxes -= 1\n            workers_efficiency.pop(0)\n        elif right and not total_boxes:\n            left += min(left - right[0][0][1], right[0][1])\n            break\n        else:\n            if left < right[0][0][1]:\n                left = right[0][0][1]\n            if left + workers_efficiency[0][1] < right[0][0][0]:\n                left += workers_efficiency[0][1]\n                events.append(((left, left + time[workers_efficiency[0][0]][1]), workers_efficiency[0][0]))\n                total_boxes -= 1\n                workers_efficiency.pop(0)\n\n            elif left + workers_efficiency[0][1] == right[0][0][0]:\n                left += workers_efficiency[0][1] * 2\n                events.append(((left, left + time[workers_efficiency[0][0]][1]), workers_efficiency[0][0]))\n                workers_efficiency.pop(0)\n                right = [x for x in right if x[0][1] > left]\n            else:\n                left += workers_efficiency[0][1]\n                right.pop(0)\n\n    return left\n```"}
{"task_id": "LeetCode-Hard/21", "completion": "\ndef countPartitions(nums: List[int], k: int) -> int:\n    MOD = 10**9 + 7\n    total_sum = sum(nums)\n    if total_sum < k * 2:\n        return 0\n\n    nums.sort()\n    dp = [0] * (total_sum + 1)\n    dp[0] = 1\n\n    for n in nums:\n        for total in range(total_sum, n - 1, -1):\n            dp[total] = (dp[total] + dp[total - n]) % MOD\n\n    result = 0\n    for i in range(k, (total_sum // 2) + 1):\n        result = (result + dp[i] * dp[total_sum - i]) % MOD\n    \n    return result\n", "raw_completion": "```python\ndef countPartitions(nums: List[int], k: int) -> int:\n    MOD = 10**9 + 7\n    total_sum = sum(nums)\n    if total_sum < k * 2:\n        return 0\n\n    nums.sort()\n    dp = [0] * (total_sum + 1)\n    dp[0] = 1\n\n    for n in nums:\n        for total in range(total_sum, n - 1, -1):\n            dp[total] = (dp[total] + dp[total - n]) % MOD\n\n    result = 0\n    for i in range(k, (total_sum // 2) + 1):\n        result = (result + dp[i] * dp[total_sum - i]) % MOD\n    \n    return result\n```"}
{"task_id": "LeetCode-Hard/7", "completion": "\ndef minCost(basket1: list[int], basket2: list[int]) -> int:\n    basket1.sort()\n    basket2.sort()\n    if basket1 == basket2:\n        return 0\n    min_cost = float('inf')\n    for i in range(len(basket1)):\n        tmp_basket1, tmp_basket2 = basket1[:], basket2[:]\n        cost = 0\n        for j in range(len(basket2)):\n            swap_cost = min(tmp_basket1[i], tmp_basket2[j])\n            tmp_basket1[i], tmp_basket2[j] = tmp_basket2[j], tmp_basket1[i]\n            cost += swap_cost\n            tmp_basket1.sort()\n            tmp_basket2.sort()\n            if tmp_basket1 == tmp_basket2:\n                min_cost = min(min_cost, cost)\n                break\n    return min_cost if min_cost != float('inf') else -1\n", "raw_completion": "```python\ndef minCost(basket1: list[int], basket2: list[int]) -> int:\n    basket1.sort()\n    basket2.sort()\n    if basket1 == basket2:\n        return 0\n    min_cost = float('inf')\n    for i in range(len(basket1)):\n        tmp_basket1, tmp_basket2 = basket1[:], basket2[:]\n        cost = 0\n        for j in range(len(basket2)):\n            swap_cost = min(tmp_basket1[i], tmp_basket2[j])\n            tmp_basket1[i], tmp_basket2[j] = tmp_basket2[j], tmp_basket1[i]\n            cost += swap_cost\n            tmp_basket1.sort()\n            tmp_basket2.sort()\n            if tmp_basket1 == tmp_basket2:\n                min_cost = min(min_cost, cost)\n                break\n    return min_cost if min_cost != float('inf') else -1\n```"}
{"task_id": "LeetCode-Hard/10", "completion": "\ndef findShortestCycle(n: int, edges: List[List[int]]) -> int:\n    from collections import deque\n    \n    def bfs(v: int, graph: List[List[int]]) -> int:\n        visited = [False] * n\n        dist = [0] * n\n        queue = deque([v])\n        visited[v] = True\n    \n        while queue:\n            current = queue.popleft()\n            for neighbor in graph[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    dist[neighbor] = dist[current] + 1\n                    queue.append(neighbor)\n                elif dist[current] > dist[neighbor]:\n                    return dist[current] - dist[neighbor] + 1\n                \n        return float('inf')\n    \n    graph = [set() for _ in range(n)]\n    \n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    result = min(bfs(v, graph) for v in range(n))\n    \n    return -1 if result == float('inf') else result\n", "raw_completion": "```python\ndef findShortestCycle(n: int, edges: List[List[int]]) -> int:\n    from collections import deque\n    \n    def bfs(v: int, graph: List[List[int]]) -> int:\n        visited = [False] * n\n        dist = [0] * n\n        queue = deque([v])\n        visited[v] = True\n    \n        while queue:\n            current = queue.popleft()\n            for neighbor in graph[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    dist[neighbor] = dist[current] + 1\n                    queue.append(neighbor)\n                elif dist[current] > dist[neighbor]:\n                    return dist[current] - dist[neighbor] + 1\n                \n        return float('inf')\n    \n    graph = [set() for _ in range(n)]\n    \n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n    \n    result = min(bfs(v, graph) for v in range(n))\n    \n    return -1 if result == float('inf') else result\n```"}
{"task_id": "LeetCode-Hard/40", "completion": "\ndef numberOfPaths(grid: list[list[int]], k: int) -> int:\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * k for _ in range(n)]\n    dp[0][0] = 1\n    mod = 10**9 + 7\n\n    for i in range(m):\n        new_dp = [[0] * k for _ in range(n)]\n        for j in range(n):\n            for mod_sum in range(k):\n                new_dp[j][mod_sum] += dp[j][mod_sum - grid[i][j]] + dp[j - 1][mod_sum - grid[i][j]]\n                new_dp[j][mod_sum] %= mod\n        dp = new_dp\n    return dp[n - 1][0]\n", "raw_completion": "```python\ndef numberOfPaths(grid: list[list[int]], k: int) -> int:\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * k for _ in range(n)]\n    dp[0][0] = 1\n    mod = 10**9 + 7\n\n    for i in range(m):\n        new_dp = [[0] * k for _ in range(n)]\n        for j in range(n):\n            for mod_sum in range(k):\n                new_dp[j][mod_sum] += dp[j][mod_sum - grid[i][j]] + dp[j - 1][mod_sum - grid[i][j]]\n                new_dp[j][mod_sum] %= mod\n        dp = new_dp\n    return dp[n - 1][0]\n```"}
{"task_id": "LeetCode-Hard/35", "completion": "\ndef makeSimilar(nums, target):\n    return sum(abs(a - b) for a, b in zip(sorted(nums), sorted(target))) // 4\n", "raw_completion": "```python\ndef makeSimilar(nums, target):\n    return sum(abs(a - b) for a, b in zip(sorted(nums), sorted(target))) // 4\n```"}
{"task_id": "LeetCode-Hard/17", "completion": "\ndef minCost(nums, k):\n    from collections import Counter\n\n    def trimmed(s):\n        c = Counter(s)\n        return len([x for x in c if c[x] > 1])\n\n    def dp(i):\n        if i == 0:\n            return 0\n        if (i, k) in memo:\n            return memo[i, k]\n        min_cost = float('inf')\n        freqs = Counter()\n        for j in range(i - 1, -1, -1):\n            freqs[nums[j]] += 1\n            if freqs[nums[j]] > 1:\n                cost = k + trimmed(nums[j:i])\n                min_cost = min(min_cost, cost + dp(j))\n        memo[i, k] = min_cost\n        return min_cost\n\n    memo = {}\n    return dp(len(nums))\n", "raw_completion": "```python\ndef minCost(nums, k):\n    from collections import Counter\n\n    def trimmed(s):\n        c = Counter(s)\n        return len([x for x in c if c[x] > 1])\n\n    def dp(i):\n        if i == 0:\n            return 0\n        if (i, k) in memo:\n            return memo[i, k]\n        min_cost = float('inf')\n        freqs = Counter()\n        for j in range(i - 1, -1, -1):\n            freqs[nums[j]] += 1\n            if freqs[nums[j]] > 1:\n                cost = k + trimmed(nums[j:i])\n                min_cost = min(min_cost, cost + dp(j))\n        memo[i, k] = min_cost\n        return min_cost\n\n    memo = {}\n    return dp(len(nums))\n```"}
{"task_id": "LeetCode-Hard/8", "completion": "\ndef countQuadruplets(nums):\n    n = len(nums)\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                for l in range(k+1, n):\n                    if nums[i] < nums[k] < nums[j] < nums[l]:\n                        count += 1\n    return count\n", "raw_completion": "```python\ndef countQuadruplets(nums):\n    n = len(nums)\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                for l in range(k+1, n):\n                    if nums[i] < nums[k] < nums[j] < nums[l]:\n                        count += 1\n    return count\n```"}
{"task_id": "LeetCode-Hard/33", "completion": "\ndef secondGreaterElement(nums):\n    n = len(nums)\n    ans = [-1] * n\n    stack = []\n\n    for i in range(n):\n        while stack and nums[stack[-1]] < nums[i]:\n            j = stack.pop()\n            if ans[j] == -1:\n                ans[j] = nums[i]\n\n        if not stack or nums[stack[-1]] > nums[i]:\n            stack.append(i)\n\n        elif ans[stack[-1]] == -1:\n            ans[stack[-1]] = nums[i]\n            stack.append(i)\n\n    return ans\n", "raw_completion": "```python\ndef secondGreaterElement(nums):\n    n = len(nums)\n    ans = [-1] * n\n    stack = []\n\n    for i in range(n):\n        while stack and nums[stack[-1]] < nums[i]:\n            j = stack.pop()\n            if ans[j] == -1:\n                ans[j] = nums[i]\n\n        if not stack or nums[stack[-1]] > nums[i]:\n            stack.append(i)\n\n        elif ans[stack[-1]] == -1:\n            ans[stack[-1]] = nums[i]\n            stack.append(i)\n\n    return ans\n```"}
{"task_id": "LeetCode-Hard/3", "completion": "\ndef findTheString(lcp):\n    n = len(lcp)\n    word = ['a'] * n\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if lcp[i][j] > lcp[j][i]:\n                return \"\"\n            if lcp[i][j] == 0:\n                word[j] = chr(ord(word[i]) + 1)\n            elif i and lcp[i][j] != lcp[i-1][j-1]:\n                return \"\"\n\n    return ''.join(word)\n", "raw_completion": "```python\ndef findTheString(lcp):\n    n = len(lcp)\n    word = ['a'] * n\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if lcp[i][j] > lcp[j][i]:\n                return \"\"\n            if lcp[i][j] == 0:\n                word[j] = chr(ord(word[i]) + 1)\n            elif i and lcp[i][j] != lcp[i-1][j-1]:\n                return \"\"\n\n    return ''.join(word)\n```"}
{"task_id": "LeetCode-Hard/39", "completion": "\ndef lengthOfLIS(nums: List[int], k: int) -> int:\n    if len(nums) == 0:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j] and nums[i] - nums[j] <= k:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n", "raw_completion": "```python\ndef lengthOfLIS(nums: List[int], k: int) -> int:\n    if len(nums) == 0:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j] and nums[i] - nums[j] <= k:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n```"}
{"task_id": "LeetCode-Hard/9", "completion": "\nfrom typing import List\n\ndef putMarbles(weights: List[int], k: int) -> int:\n    n = len(weights)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + weights[i]\n\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if j == 1:\n                dp[i][j] = weights[0] + weights[i - 1]\n            elif i > j:\n                dp[i][j] = float('inf')\n                for p in range(0, i):\n                    dp[i][j] = min(dp[i][j], dp[p][j - 1] + weights[p] + weights[i - 1] - prefix_sum[p + 1] + prefix_sum[i])\n\n    return dp[n][k] - dp[n][1]\n", "raw_completion": "```python\nfrom typing import List\n\ndef putMarbles(weights: List[int], k: int) -> int:\n    n = len(weights)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + weights[i]\n\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if j == 1:\n                dp[i][j] = weights[0] + weights[i - 1]\n            elif i > j:\n                dp[i][j] = float('inf')\n                for p in range(0, i):\n                    dp[i][j] = min(dp[i][j], dp[p][j - 1] + weights[p] + weights[i - 1] - prefix_sum[p + 1] + prefix_sum[i])\n\n    return dp[n][k] - dp[n][1]\n```"}
{"task_id": "LeetCode-Hard/4", "completion": "\ndef handleQuery(nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n    result = []\n    for query in queries:\n        if query[0] == 1:\n            for i in range(query[1], query[2] + 1):\n                nums1[i] = 1 - nums1[i]\n        elif query[0] == 2:\n            for i in range(len(nums1)):\n                nums2[i] += nums1[i] * query[1]\n        elif query[0] == 3:\n            result.append(sum(nums2))\n    return result\n", "raw_completion": "```python\ndef handleQuery(nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n    result = []\n    for query in queries:\n        if query[0] == 1:\n            for i in range(query[1], query[2] + 1):\n                nums1[i] = 1 - nums1[i]\n        elif query[0] == 2:\n            for i in range(len(nums1)):\n                nums2[i] += nums1[i] * query[1]\n        elif query[0] == 3:\n            result.append(sum(nums2))\n    return result\n```"}
{"task_id": "LeetCode-Hard/37", "completion": "\ndef componentValue(nums, edges):\n    from collections import defaultdict\n    \n    def dfs(node):\n        visited.add(node)\n        total = nums[node]\n        same_value = 0\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                current, same = dfs(neighbor)\n                total += current\n                same_value += same\n                \n        return total, same_value + int(total == target)\n    \n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    target = sum(nums) // len(set(nums))\n    visited = set()\n\n    if target == 0:\n        return len(edges)\n    else:\n        _, res = dfs(0)\n        return res - 1 if res else 0\n", "raw_completion": "```python\ndef componentValue(nums, edges):\n    from collections import defaultdict\n    \n    def dfs(node):\n        visited.add(node)\n        total = nums[node]\n        same_value = 0\n        \n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                current, same = dfs(neighbor)\n                total += current\n                same_value += same\n                \n        return total, same_value + int(total == target)\n    \n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        \n    target = sum(nums) // len(set(nums))\n    visited = set()\n\n    if target == 0:\n        return len(edges)\n    else:\n        _, res = dfs(0)\n        return res - 1 if res else 0\n```"}
{"task_id": "LeetCode-Hard/6", "completion": "\ndef minimumVisitedCells(grid):\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf') for _ in range(n)] for _ in range(m)]\n    dp[0][0] = 1\n    for i in range(m):\n        for j in range(n):\n            if dp[i][j] == float('inf'):\n                continue\n            for k in range(1, grid[i][j] + 1):\n                if j + k < n:\n                    dp[i][j + k] = min(dp[i][j + k], dp[i][j] + 1)\n                if i + k < m:\n                    dp[i + k][j] = min(dp[i + k][j], dp[i][j] + 1)\n    return dp[m - 1][n - 1] if dp[m - 1][n - 1] != float('inf') else -1\n", "raw_completion": "```python\ndef minimumVisitedCells(grid):\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf') for _ in range(n)] for _ in range(m)]\n    dp[0][0] = 1\n    for i in range(m):\n        for j in range(n):\n            if dp[i][j] == float('inf'):\n                continue\n            for k in range(1, grid[i][j] + 1):\n                if j + k < n:\n                    dp[i][j + k] = min(dp[i][j + k], dp[i][j] + 1)\n                if i + k < m:\n                    dp[i + k][j] = min(dp[i + k][j], dp[i][j] + 1)\n    return dp[m - 1][n - 1] if dp[m - 1][n - 1] != float('inf') else -1\n```\n"}
{"task_id": "LeetCode-Hard/28", "completion": "def countSubarrays(nums: list[int], k: int) -> int:\n    count = 0\n    for i in range(len(nums)):\n        if nums[i] == k:\n            left = i\n            right = len(nums) - i - 1\n            count += (left + 1) * (right + 1)\n    return count", "raw_completion": "def countSubarrays(nums: list[int], k: int) -> int:\n    count = 0\n    for i in range(len(nums)):\n        if nums[i] == k:\n            left = i\n            right = len(nums) - i - 1\n            count += (left + 1) * (right + 1)\n    return count"}
{"task_id": "LeetCode-Hard/18", "completion": "\ndef maxOutput(n: int, edges: List[List[int]], price: List[int]) -> int:\n    from collections import defaultdict\n    \n    def dfs(node, parent, cost, curr_cost):\n        nonlocal max_cost, min_cost\n        curr_cost += price[node]\n        max_cost = max(max_cost, curr_cost)\n        min_cost = min(min_cost, curr_cost)\n        \n        for neighbor in tree[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, cost, curr_cost)\n        \n    tree = defaultdict(list)\n    for a, b in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    \n    max_profit = 0\n    \n    for root in range(n):\n        max_cost, min_cost = -float('inf'), float('inf')\n        dfs(root, -1, 0, 0)\n        max_profit = max(max_profit, max_cost - min_cost)\n    \n    return max_profit\n", "raw_completion": "```python\ndef maxOutput(n: int, edges: List[List[int]], price: List[int]) -> int:\n    from collections import defaultdict\n    \n    def dfs(node, parent, cost, curr_cost):\n        nonlocal max_cost, min_cost\n        curr_cost += price[node]\n        max_cost = max(max_cost, curr_cost)\n        min_cost = min(min_cost, curr_cost)\n        \n        for neighbor in tree[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, cost, curr_cost)\n        \n    tree = defaultdict(list)\n    for a, b in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    \n    max_profit = 0\n    \n    for root in range(n):\n        max_cost, min_cost = -float('inf'), float('inf')\n        dfs(root, -1, 0, 0)\n        max_profit = max(max_profit, max_cost - min_cost)\n    \n    return max_profit\n```"}
{"task_id": "LeetCode-Hard/22", "completion": "\ndef cycleLengthQueries(n: int, queries: list[list[int]]) -> list[int]:\n\n    def find_path(val: int) -> list[int]:\n        path = []\n        while val > 0:\n            path.append(val)\n            val //= 2\n        return path[::-1]\n\n    answers = []\n    for query in queries:\n        a, b = query\n        a_path, b_path = find_path(a), find_path(b)\n        while a_path and b_path and a_path[0] == b_path[0]:\n            a_path.pop(0)\n            b_path.pop(0)\n\n        cycle_length = len(a_path) + len(b_path)\n        answers.append(cycle_length)\n\n    return answers\n", "raw_completion": "```python\ndef cycleLengthQueries(n: int, queries: list[list[int]]) -> list[int]:\n\n    def find_path(val: int) -> list[int]:\n        path = []\n        while val > 0:\n            path.append(val)\n            val //= 2\n        return path[::-1]\n\n    answers = []\n    for query in queries:\n        a, b = query\n        a_path, b_path = find_path(a), find_path(b)\n        while a_path and b_path and a_path[0] == b_path[0]:\n            a_path.pop(0)\n            b_path.pop(0)\n\n        cycle_length = len(a_path) + len(b_path)\n        answers.append(cycle_length)\n\n    return answers\n```"}
{"task_id": "LeetCode-Hard/30", "completion": "\ndef splitMessage(message: str, limit: int) -> list[str]:\n    if limit < 5:\n        return []\n    parts_count = (len(message) + (limit - 5)) // (limit - 4)\n    parts = []\n    for i in range(parts_count):\n        cur = limit - 4\n        if len(message) < cur:\n            cur = len(message)\n        part = message[:cur] + f\"<{i + 1}/{parts_count}>\"\n        parts.append(part)\n        message = message[cur:]\n    return parts\n", "raw_completion": "```python\ndef splitMessage(message: str, limit: int) -> list[str]:\n    if limit < 5:\n        return []\n    parts_count = (len(message) + (limit - 5)) // (limit - 4)\n    parts = []\n    for i in range(parts_count):\n        cur = limit - 4\n        if len(message) < cur:\n            cur = len(message)\n        part = message[:cur] + f\"<{i + 1}/{parts_count}>\"\n        parts.append(part)\n        message = message[cur:]\n    return parts\n```"}
{"task_id": "LeetCode-Hard/19", "completion": "def maxPower(stations: list[int], r: int, k: int) -> int:\n    n = len(stations)\n    total_power = sum(stations)\n    \n    for _ in range(k):\n        min_power = min(range(n), key=lambda i: sum(stations[max(0, i-r):min(n, i+r+1)]))\n        stations[min_power] += 1\n\n    return min(sum(stations[max(0, i-r):min(n, i+r+1)]) for i in range(n))", "raw_completion": "def maxPower(stations: list[int], r: int, k: int) -> int:\n    n = len(stations)\n    total_power = sum(stations)\n    \n    for _ in range(k):\n        min_power = min(range(n), key=lambda i: sum(stations[max(0, i-r):min(n, i+r+1)]))\n        stations[min_power] += 1\n\n    return min(sum(stations[max(0, i-r):min(n, i+r+1)]) for i in range(n))"}
{"task_id": "LeetCode-Hard/25", "completion": "\ndef maxPoints(grid: List[List[int]], queries: List[int]) -> List[int]:\n    m, n = len(grid), len(grid[0])\n    memo = {}\n\n    def dfs(x, y, k):\n        if (x, y, k) in memo:\n            return memo[(x, y, k)]\n        if x < 0 or y < 0 or x >= m or y >= n or grid[x][y] >= k:\n            return 0\n        memo[(x, y, k)] = 1 + max(dfs(x+1, y, k), dfs(x-1, y, k), dfs(x, y+1, k), dfs(x, y-1, k))\n        return memo[(x, y, k)]\n\n    return [dfs(0, 0, q) for q in queries]\n", "raw_completion": "```python\ndef maxPoints(grid: List[List[int]], queries: List[int]) -> List[int]:\n    m, n = len(grid), len(grid[0])\n    memo = {}\n\n    def dfs(x, y, k):\n        if (x, y, k) in memo:\n            return memo[(x, y, k)]\n        if x < 0 or y < 0 or x >= m or y >= n or grid[x][y] >= k:\n            return 0\n        memo[(x, y, k)] = 1 + max(dfs(x+1, y, k), dfs(x-1, y, k), dfs(x, y+1, k), dfs(x, y-1, k))\n        return memo[(x, y, k)]\n\n    return [dfs(0, 0, q) for q in queries]\n```"}
{"task_id": "LeetCode-Hard/31", "completion": "\ndef maxPalindromes(s: str, k: int) -> int:\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    count = 0\n    i = 0\n    while i < len(s) - k + 1:\n        j = len(s) - 1\n        while j >= i + k - 1:\n            if is_palindrome(s, i, j):\n                count += 1\n                i = j + 1\n                break\n            j -= 1\n        i += 1\n\n    return count\n", "raw_completion": "```python\ndef maxPalindromes(s: str, k: int) -> int:\n    def is_palindrome(s, start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n\n    count = 0\n    i = 0\n    while i < len(s) - k + 1:\n        j = len(s) - 1\n        while j >= i + k - 1:\n            if is_palindrome(s, i, j):\n                count += 1\n                i = j + 1\n                break\n            j -= 1\n        i += 1\n\n    return count\n```"}
{"task_id": "LeetCode-Hard/32", "completion": "\ndef minimumTotalDistance(robot: list[int], factory: list[list[int]]) -> int:\n    robot.sort()\n    for f in factory:\n        f.append(0)\n    factory.sort()\n    i = 0\n    j = 0\n    d = 0\n    while i < len(robot):\n        if j == len(factory) or factory[j][1] == factory[j][2]:\n            j += 1\n            continue\n        if factory[j][0] < robot[i] or (factory[j - 1][1] != factory[j - 1][2] and robot[i] - factory[j - 1][0] < factory[j][0] - robot[i]):\n            d += abs(robot[i] - factory[j - 1][0])\n            factory[j - 1][2] += 1\n        else:\n            d += abs(robot[i] - factory[j][0])\n            factory[j][2] += 1\n        i += 1\n    return d\n", "raw_completion": "```python\ndef minimumTotalDistance(robot: list[int], factory: list[list[int]]) -> int:\n    robot.sort()\n    for f in factory:\n        f.append(0)\n    factory.sort()\n    i = 0\n    j = 0\n    d = 0\n    while i < len(robot):\n        if j == len(factory) or factory[j][1] == factory[j][2]:\n            j += 1\n            continue\n        if factory[j][0] < robot[i] or (factory[j - 1][1] != factory[j - 1][2] and robot[i] - factory[j - 1][0] < factory[j][0] - robot[i]):\n            d += abs(robot[i] - factory[j - 1][0])\n            factory[j - 1][2] += 1\n        else:\n            d += abs(robot[i] - factory[j][0])\n            factory[j][2] += 1\n        i += 1\n    return d\n```"}
{"task_id": "LeetCode-Hard/16", "completion": "\ndef isReachable(targetX: int, targetY: int) -> bool:\n    while targetX > 0 and targetY > 0:\n        if targetX > targetY:\n            targetX %= targetY\n        else:\n            targetY %= targetX\n    return targetX == 1 or targetY == 1\n", "raw_completion": "```python\ndef isReachable(targetX: int, targetY: int) -> bool:\n    while targetX > 0 and targetY > 0:\n        if targetX > targetY:\n            targetX %= targetY\n        else:\n            targetY %= targetX\n    return targetX == 1 or targetY == 1\n```"}
{"task_id": "LeetCode-Hard/2", "completion": "\ndef minimumTime(grid: list[list[int]]) -> int:\n    queue = [(0, 0, 0)]\n    visited = {(0, 0)}\n    while queue:\n        x, y, time = queue.pop(0)\n        if (x, y) == (len(grid) - 1, len(grid[0]) - 1):\n            return time\n        for dx, dy in ((1, 0), (0, 1), (-1, 0), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and\n                (nx, ny) not in visited and time + 1 >= grid[nx][ny]):\n                queue.append((nx, ny, time + 1))\n                visited.add((nx, ny))\n    return -1\n", "raw_completion": "```python\ndef minimumTime(grid: list[list[int]]) -> int:\n    queue = [(0, 0, 0)]\n    visited = {(0, 0)}\n    while queue:\n        x, y, time = queue.pop(0)\n        if (x, y) == (len(grid) - 1, len(grid[0]) - 1):\n            return time\n        for dx, dy in ((1, 0), (0, 1), (-1, 0), (0, -1)):\n            nx, ny = x + dx, y + dy\n            if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and\n                (nx, ny) not in visited and time + 1 >= grid[nx][ny]):\n                queue.append((nx, ny, time + 1))\n                visited.add((nx, ny))\n    return -1\n```"}
{"task_id": "LeetCode-Hard/26", "completion": "\ndef magnificentSets(n: int, edges: List[List[int]]) -> int:\n    connections = [set() for _ in range(n + 1)]\n    for a, b in edges:\n        connections[a].add(b)\n        connections[b].add(a)\n\n    groups = [0] * (n + 1)\n    \n    def bfs(node):\n        queue = [(node, 1)]\n        while queue:\n            curr, group = queue.pop(0)\n            if not groups[curr]:\n                groups[curr] = group\n                for neighbor in connections[curr]:\n                    queue.append((neighbor, 3 - group))\n            elif groups[curr] != group:\n                return False\n    for i in range(1, n + 1):\n        if not groups[i] and not bfs(i):\n            return -1\n    return max(groups)\n", "raw_completion": "```python\ndef magnificentSets(n: int, edges: List[List[int]]) -> int:\n    connections = [set() for _ in range(n + 1)]\n    for a, b in edges:\n        connections[a].add(b)\n        connections[b].add(a)\n\n    groups = [0] * (n + 1)\n    \n    def bfs(node):\n        queue = [(node, 1)]\n        while queue:\n            curr, group = queue.pop(0)\n            if not groups[curr]:\n                groups[curr] = group\n                for neighbor in connections[curr]:\n                    queue.append((neighbor, 3 - group))\n            elif groups[curr] != group:\n                return False\n    for i in range(1, n + 1):\n        if not groups[i] and not bfs(i):\n            return -1\n    return max(groups)\n```"}
{"task_id": "LeetCode-Hard/24", "completion": "\ndef minimumTotalCost(nums1: List[int], nums2: List[int]) -> int:\n    nums1.sort()\n    nums2.sort()\n    cost = 0\n    for i in range(len(nums1)):\n        if nums1[i] == nums2[i]:\n            if i < len(nums1) - 1:\n                cost += i + (i + 1)\n                nums1[i], nums1[i + 1] = nums1[i + 1], nums1[i]\n            else:\n                return -1\n    return cost\n", "raw_completion": "```python\ndef minimumTotalCost(nums1: List[int], nums2: List[int]) -> int:\n    nums1.sort()\n    nums2.sort()\n    cost = 0\n    for i in range(len(nums1)):\n        if nums1[i] == nums2[i]:\n            if i < len(nums1) - 1:\n                cost += i + (i + 1)\n                nums1[i], nums1[i + 1] = nums1[i + 1], nums1[i]\n            else:\n                return -1\n    return cost\n```"}
{"task_id": "LeetCode-Hard/29", "completion": "\ndef beautifulPartitions(s: str, k: int, minLength: int) -> int:\n    prime_digits = set(\"2357\")\n    non_prime_digits = set(\"14689\")\n    MOD = 1000000007\n\n    def countBeautifulFrom(i, k_remaining):\n        if k_remaining == 0:\n            return i == len(s)\n        if i >= len(s) or s[i] not in prime_digits:\n            return 0\n        count = 0\n        for j in range(minLength + i, len(s) + 1):\n            if s[j - 1] in non_prime_digits:\n                count += countBeautifulFrom(j, k_remaining - 1)\n                count %= MOD\n        return count\n\n    return countBeautifulFrom(0, k)\n", "raw_completion": "```python\ndef beautifulPartitions(s: str, k: int, minLength: int) -> int:\n    prime_digits = set(\"2357\")\n    non_prime_digits = set(\"14689\")\n    MOD = 1000000007\n\n    def countBeautifulFrom(i, k_remaining):\n        if k_remaining == 0:\n            return i == len(s)\n        if i >= len(s) or s[i] not in prime_digits:\n            return 0\n        count = 0\n        for j in range(minLength + i, len(s) + 1):\n            if s[j - 1] in non_prime_digits:\n                count += countBeautifulFrom(j, k_remaining - 1)\n                count %= MOD\n        return count\n\n    return countBeautifulFrom(0, k)\n```"}
{"task_id": "LeetCode-Hard/12", "completion": "\ndef rootCount(edges, guesses, k):\n    possible_roots = set(range(len(edges) + 1))\n    adj_list = [[] for _ in range(len(edges) + 1)]\n\n    for a, b in edges:\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n\n    for i in range(len(guesses)):\n        if guesses[i][1] in adj_list[guesses[i][0]]:\n            adj_list[guesses[i][0]].remove(guesses[i][1])\n\n    for i in range(len(guesses)):\n        if guesses[i][0] in adj_list[guesses[i][1]]:\n            adj_list[guesses[i][1]].remove(guesses[i][0])\n\n    def dfs(node, parent, count):\n        if count > len(guesses) - k:\n            possible_roots.discard(node)\n        for child in adj_list[node]:\n            if child != parent:\n                dfs(child, node, count + 1 if [node, child] in guesses else count)\n\n    root = next(iter(possible_roots))\n    dfs(root, -1, 1 if [root, adj_list[root][0]] in guesses else 0)\n    return len(possible_roots)\n", "raw_completion": "```python\ndef rootCount(edges, guesses, k):\n    possible_roots = set(range(len(edges) + 1))\n    adj_list = [[] for _ in range(len(edges) + 1)]\n\n    for a, b in edges:\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n\n    for i in range(len(guesses)):\n        if guesses[i][1] in adj_list[guesses[i][0]]:\n            adj_list[guesses[i][0]].remove(guesses[i][1])\n\n    for i in range(len(guesses)):\n        if guesses[i][0] in adj_list[guesses[i][1]]:\n            adj_list[guesses[i][1]].remove(guesses[i][0])\n\n    def dfs(node, parent, count):\n        if count > len(guesses) - k:\n            possible_roots.discard(node)\n        for child in adj_list[node]:\n            if child != parent:\n                dfs(child, node, count + 1 if [node, child] in guesses else count)\n\n    root = next(iter(possible_roots))\n    dfs(root, -1, 1 if [root, adj_list[root][0]] in guesses else 0)\n    return len(possible_roots)\n```"}
{"task_id": "LeetCode-Hard/36", "completion": "\ndef minCost(nums: List[int], cost: List[int]) -> int:\n    median = sorted(nums)[len(nums) // 2]\n    return sum(abs(nums[i] - median) * cost[i] for i in range(len(nums)))\n", "raw_completion": "```python\ndef minCost(nums: List[int], cost: List[int]) -> int:\n    median = sorted(nums)[len(nums) // 2]\n    return sum(abs(nums[i] - median) * cost[i] for i in range(len(nums)))\n```"}
{"task_id": "LeetCode-Hard/27", "completion": "\ndef countPalindromes(s: str) -> int:\n    mod = 10**9 + 7\n    n = len(s)\n    cnt = [[0] * 10 for _ in range(n)]\n    \n    for i in range(n):\n        cnt[i][int(s[i])] += 1\n\n    for i in range(1, n):\n        for j in range(10):\n            cnt[i][j] += cnt[i - 1][j]\n\n    ans = 0\n    for i in range(2, n - 2):\n        ans += cnt[i][int(s[i])] * (cnt[i - 1][int(s[i])] - cnt[i][int(s[i])]) * cnt[i - 1][int(s[i])] * (i - cnt[i - 1][int(s[i])]) * (n - i - 1)\n        ans %= mod\n    \n    return ans\n", "raw_completion": "```python\ndef countPalindromes(s: str) -> int:\n    mod = 10**9 + 7\n    n = len(s)\n    cnt = [[0] * 10 for _ in range(n)]\n    \n    for i in range(n):\n        cnt[i][int(s[i])] += 1\n\n    for i in range(1, n):\n        for j in range(10):\n            cnt[i][j] += cnt[i - 1][j]\n\n    ans = 0\n    for i in range(2, n - 2):\n        ans += cnt[i][int(s[i])] * (cnt[i - 1][int(s[i])] - cnt[i][int(s[i])]) * cnt[i - 1][int(s[i])] * (i - cnt[i - 1][int(s[i])]) * (n - i - 1)\n        ans %= mod\n    \n    return ans\n```"}
{"task_id": "LeetCode-Hard/11", "completion": "\ndef findMinimumTime(tasks):\n    tasks = sorted(tasks, key=lambda x: (x[1], x[0]))\n    q = []\n    ans = 0\n    for t in tasks:\n        start, end, duration = t\n        while q and q[0][1] < start:\n            ans += q.pop(0)[0]\n        if not q:\n            ans += duration\n        else:\n            q[0][0] -= duration\n            q.sort()\n        q.append([duration, end])\n    return ans\n", "raw_completion": "```python\ndef findMinimumTime(tasks):\n    tasks = sorted(tasks, key=lambda x: (x[1], x[0]))\n    q = []\n    ans = 0\n    for t in tasks:\n        start, end, duration = t\n        while q and q[0][1] < start:\n            ans += q.pop(0)[0]\n        if not q:\n            ans += duration\n        else:\n            q[0][0] -= duration\n            q.sort()\n        q.append([duration, end])\n    return ans\n```"}
{"task_id": "LeetCode-Hard/1", "completion": "\ndef collectTheCoins(coins, edges):\n    neighbors = [[] for _ in range(len(coins))]\n    for a, b in edges:\n        neighbors[a].append(b)\n        neighbors[b].append(a)\n\n    def dfs(node, parent):\n        children_count = 0\n        max_distance = 0\n        total_distance = 0\n        for child in neighbors[node]:\n            if child == parent:\n                continue\n            children_count += 1\n            child_length, child_max_distance = dfs(child, node)\n            total_distance += child_length + (coins[child] == 1)\n            max_distance = max(max_distance, child_max_distance + (coins[child] == 1))\n\n        if children_count == 0:\n            return (0, 0)\n        return (total_distance - max_distance, max_distance)\n\n    return dfs(0, -1)[0]\n\n", "raw_completion": "```python\ndef collectTheCoins(coins, edges):\n    neighbors = [[] for _ in range(len(coins))]\n    for a, b in edges:\n        neighbors[a].append(b)\n        neighbors[b].append(a)\n\n    def dfs(node, parent):\n        children_count = 0\n        max_distance = 0\n        total_distance = 0\n        for child in neighbors[node]:\n            if child == parent:\n                continue\n            children_count += 1\n            child_length, child_max_distance = dfs(child, node)\n            total_distance += child_length + (coins[child] == 1)\n            max_distance = max(max_distance, child_max_distance + (coins[child] == 1))\n\n        if children_count == 0:\n            return (0, 0)\n        return (total_distance - max_distance, max_distance)\n\n    return dfs(0, -1)[0]\n\n```"}
{"task_id": "LeetCode-Hard/5", "completion": "\ndef minimumScore(s: str, t: str) -> int:\n    n, m = len(s), len(t)\n    remove_idx = []\n    for i in range(m):\n        remove_idx.append([-1] * (n + 1))\n    for i in range(n + 1):\n        remove_idx[0][i] = i\n    for i in range(1, m):\n        p = -1\n        for j in range(n):\n            remove_idx[i][j] = p if s[j] == t[i - 1] else remove_idx[i - 1][j]\n            p = remove_idx[i - 1][j]\n    best_score = n\n    j = n - 1\n    for i in range(m - 1, -1, -1):\n        while j >= 0 and (i == m - 1 or remove_idx[i + 1][j] != -1):\n            score = j - remove_idx[i][j] if remove_idx[i][j] != -1 else n\n            if score < best_score:\n                best_score = score\n            j -= 1\n    return best_score\n", "raw_completion": "```python\ndef minimumScore(s: str, t: str) -> int:\n    n, m = len(s), len(t)\n    remove_idx = []\n    for i in range(m):\n        remove_idx.append([-1] * (n + 1))\n    for i in range(n + 1):\n        remove_idx[0][i] = i\n    for i in range(1, m):\n        p = -1\n        for j in range(n):\n            remove_idx[i][j] = p if s[j] == t[i - 1] else remove_idx[i - 1][j]\n            p = remove_idx[i - 1][j]\n    best_score = n\n    j = n - 1\n    for i in range(m - 1, -1, -1):\n        while j >= 0 and (i == m - 1 or remove_idx[i + 1][j] != -1):\n            score = j - remove_idx[i][j] if remove_idx[i][j] != -1 else n\n            if score < best_score:\n                best_score = score\n            j -= 1\n    return best_score\n```"}
{"task_id": "LeetCode-Hard/13", "completion": "\ndef waysToReachTarget(target: int, types: list[list[int]]) -> int:\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    MOD = 10**9 + 7\n    \n    for count, marks in types:\n        for j in range(target, -1, -1):\n            for k in range(1, count + 1):\n                if j - k * marks >= 0:\n                    dp[j] = (dp[j] + dp[j - k * marks]) % MOD\n                    \n    return dp[target]\n", "raw_completion": "```python\ndef waysToReachTarget(target: int, types: list[list[int]]) -> int:\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    MOD = 10**9 + 7\n    \n    for count, marks in types:\n        for j in range(target, -1, -1):\n            for k in range(1, count + 1):\n                if j - k * marks >= 0:\n                    dp[j] = (dp[j] + dp[j - k * marks]) % MOD\n                    \n    return dp[target]\n```"}
{"task_id": "LeetCode-Hard/14", "completion": "\nfrom math import gcd\nfrom typing import List\n\ndef findValidSplit(nums: List[int]) -> int:\n    n = len(nums)\n    left_product = [nums[0]]\n    right_product = [nums[-1]]\n    \n    for i in range(1, n):\n        left_product.append(left_product[-1] * nums[i])\n        right_product.append(right_product[-1] * nums[n-i-1])\n    \n    right_product.reverse()\n    \n    for i in range(n - 1):\n        if gcd(left_product[i], right_product[i+1]) == 1:\n            return i\n    \n    return -1\n", "raw_completion": "```python\nfrom math import gcd\nfrom typing import List\n\ndef findValidSplit(nums: List[int]) -> int:\n    n = len(nums)\n    left_product = [nums[0]]\n    right_product = [nums[-1]]\n    \n    for i in range(1, n):\n        left_product.append(left_product[-1] * nums[i])\n        right_product.append(right_product[-1] * nums[n-i-1])\n    \n    right_product.reverse()\n    \n    for i in range(n - 1):\n        if gcd(left_product[i], right_product[i+1]) == 1:\n            return i\n    \n    return -1\n```"}
{"task_id": "LeetCode-Hard/38", "completion": "\ndef countSubarrays(nums, minK, maxK):\n    count = 0\n    for i in range(len(nums)):\n        min_val = max_val = nums[i]\n        for j in range(i, len(nums)):\n            min_val = min(min_val, nums[j])\n            max_val = max(max_val, nums[j])\n            if min_val == minK and max_val == maxK:\n                count += 1\n    return count\n", "raw_completion": "```python\ndef countSubarrays(nums, minK, maxK):\n    count = 0\n    for i in range(len(nums)):\n        min_val = max_val = nums[i]\n        for j in range(i, len(nums)):\n            min_val = min(min_val, nums[j])\n            max_val = max(max_val, nums[j])\n            if min_val == minK and max_val == maxK:\n                count += 1\n    return count\n```"}
{"task_id": "LeetCode-Hard/23", "completion": "\ndef isPossible(n: int, edges: list[list[int]]) -> bool:\n    degrees = [0] * (n + 1)\n    for a, b in edges:\n        degrees[a] += 1\n        degrees[b] += 1\n    odd_degrees = [x for x in range(1, n + 1) if degrees[x] % 2 == 1]\n    \n    if len(odd_degrees) == 0 or len(odd_degrees) == 2:\n        return True\n    elif len(odd_degrees) == 4:\n        for i in range(3):\n            for j in range(i + 1, 4):\n                if (odd_degrees[i], odd_degrees[j]) not in edges and (odd_degrees[j], odd_degrees[i]) not in edges:\n                    return True\n    return False\n", "raw_completion": "```python\ndef isPossible(n: int, edges: list[list[int]]) -> bool:\n    degrees = [0] * (n + 1)\n    for a, b in edges:\n        degrees[a] += 1\n        degrees[b] += 1\n    odd_degrees = [x for x in range(1, n + 1) if degrees[x] % 2 == 1]\n    \n    if len(odd_degrees) == 0 or len(odd_degrees) == 2:\n        return True\n    elif len(odd_degrees) == 4:\n        for i in range(3):\n            for j in range(i + 1, 4):\n                if (odd_degrees[i], odd_degrees[j]) not in edges and (odd_degrees[j], odd_degrees[i]) not in edges:\n                    return True\n    return False\n```"}
{"task_id": "LeetCode-Hard/34", "completion": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef treeQueries(root: Optional[TreeNode], queries: List[int]) -> List[int]:\n    def findNode(node, value):\n        if not node:\n            return None\n        if node.val == value:\n            return node\n        left = findNode(node.left, value)\n        if left:\n            return left\n        right = findNode(node.right, value)\n        if right:\n            return right\n        return None\n\n    def removeSubtree(node):\n        node.left = None\n        node.right = None\n\n    def maxHeight(node):\n        if not node:\n            return 0\n        return max(maxHeight(node.left), maxHeight(node.right)) + 1\n\n    result = []\n    for q in queries:\n        node = findNode(root, q)\n        removeSubtree(node)\n        result.append(maxHeight(root) - 1)\n    return result\n", "raw_completion": "```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef treeQueries(root: Optional[TreeNode], queries: List[int]) -> List[int]:\n    def findNode(node, value):\n        if not node:\n            return None\n        if node.val == value:\n            return node\n        left = findNode(node.left, value)\n        if left:\n            return left\n        right = findNode(node.right, value)\n        if right:\n            return right\n        return None\n\n    def removeSubtree(node):\n        node.left = None\n        node.right = None\n\n    def maxHeight(node):\n        if not node:\n            return 0\n        return max(maxHeight(node.left), maxHeight(node.right)) + 1\n\n    result = []\n    for q in queries:\n        node = findNode(root, q)\n        removeSubtree(node)\n        result.append(maxHeight(root) - 1)\n    return result\n```"}