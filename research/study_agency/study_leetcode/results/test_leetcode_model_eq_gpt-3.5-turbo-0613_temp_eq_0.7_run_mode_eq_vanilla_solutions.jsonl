{"task_id": "LeetCode-Hard/0", "completion": "\nfrom typing import List\n\ndef minReverseOperations(n: int, p: int, banned: List[int], k: int) -> List[int]:\n    def reverse(arr: List[int], start: int, end: int):\n        while start < end:\n            arr[start], arr[end] = arr[end], arr[start]\n            start += 1\n            end -= 1\n\n    def is_valid(arr: List[int], banned: List[int], p: int):\n        for b in banned:\n            if arr[b] == 1 and b != p:\n                return False\n        return True\n\n    arr = [0] * n\n    arr[p] = 1\n    ans = [-1] * n\n\n    for i in range(n):\n        if is_valid(arr, banned, i):\n            ans[i] = 0\n\n    if k == n and ans[p] == -1:\n        return ans\n\n    for i in range(n):\n        if ans[i] == -1:\n            return ans\n\n    if k == n:\n        return ans\n\n    moves = n // k\n    left = n % k\n\n    for i in range(n):\n        if ans[i] != -1:\n            if ans[i] % 2 == 0:\n                ans[i] += moves\n            else:\n                ans[i] += moves + 1\n\n    for i in range(n):\n        if ans[i] != -1:\n            if i - k + 1 < 0 or i >= n - k + 1:\n                continue\n            if ans[i - k + 1] != -1 and ans[i - k + 1] % 2 == 0:\n                ans[i] = min(ans[i], ans[i - k + 1] + 1)\n\n    for i in range(n - 1, -1, -1):\n        if ans[i] != -1:\n            if i + k - 1 >= n or i < k - 1:\n                continue\n            if ans[i + k - 1] != -1 and ans[i + k - 1] % 2 == 0:\n                ans[i] = min(ans[i], ans[i + k - 1] + 1)\n\n    for i in range(n):\n        arr[i] = i\n\n    for i in range(0, n, k):\n        reverse(arr, i, min(i + k - 1, n - 1))\n\n    for i in range(n):\n        if ans[i] != -1:\n            j = arr.index(i)\n            if j >= i - k + 1 and j < i:\n                ans[i] = min(ans[i], ans[j - 1] + 1)\n\n    return ans\n", "raw_completion": "```python\nfrom typing import List\n\ndef minReverseOperations(n: int, p: int, banned: List[int], k: int) -> List[int]:\n    def reverse(arr: List[int], start: int, end: int):\n        while start < end:\n            arr[start], arr[end] = arr[end], arr[start]\n            start += 1\n            end -= 1\n\n    def is_valid(arr: List[int], banned: List[int], p: int):\n        for b in banned:\n            if arr[b] == 1 and b != p:\n                return False\n        return True\n\n    arr = [0] * n\n    arr[p] = 1\n    ans = [-1] * n\n\n    for i in range(n):\n        if is_valid(arr, banned, i):\n            ans[i] = 0\n\n    if k == n and ans[p] == -1:\n        return ans\n\n    for i in range(n):\n        if ans[i] == -1:\n            return ans\n\n    if k == n:\n        return ans\n\n    moves = n // k\n    left = n % k\n\n    for i in range(n):\n        if ans[i] != -1:\n            if ans[i] % 2 == 0:\n                ans[i] += moves\n            else:\n                ans[i] += moves + 1\n\n    for i in range(n):\n        if ans[i] != -1:\n            if i - k + 1 < 0 or i >= n - k + 1:\n                continue\n            if ans[i - k + 1] != -1 and ans[i - k + 1] % 2 == 0:\n                ans[i] = min(ans[i], ans[i - k + 1] + 1)\n\n    for i in range(n - 1, -1, -1):\n        if ans[i] != -1:\n            if i + k - 1 >= n or i < k - 1:\n                continue\n            if ans[i + k - 1] != -1 and ans[i + k - 1] % 2 == 0:\n                ans[i] = min(ans[i], ans[i + k - 1] + 1)\n\n    for i in range(n):\n        arr[i] = i\n\n    for i in range(0, n, k):\n        reverse(arr, i, min(i + k - 1, n - 1))\n\n    for i in range(n):\n        if ans[i] != -1:\n            j = arr.index(i)\n            if j >= i - k + 1 and j < i:\n                ans[i] = min(ans[i], ans[j - 1] + 1)\n\n    return ans\n```"}
{"task_id": "LeetCode-Hard/29", "completion": "\ndef beautifulPartitions(s: str, k: int, minLength: int) -> int:\n    if k > len(s) // minLength:\n        return 0\n    \n    dp = [[0] * (len(s) + 1) for _ in range(k + 1)]\n    dp[0][0] = 1\n    \n    primes = set(['2', '3', '5', '7'])\n    mod = 10 ** 9 + 7\n    \n    for i in range(1, k + 1):\n        for j in range(1, len(s) + 1):\n            for x in range(j - minLength, -1, -1):\n                if s[x] in primes and s[j - 1] not in primes:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][x]) % mod\n\n    return dp[k][len(s)]\n", "raw_completion": "```python\ndef beautifulPartitions(s: str, k: int, minLength: int) -> int:\n    if k > len(s) // minLength:\n        return 0\n    \n    dp = [[0] * (len(s) + 1) for _ in range(k + 1)]\n    dp[0][0] = 1\n    \n    primes = set(['2', '3', '5', '7'])\n    mod = 10 ** 9 + 7\n    \n    for i in range(1, k + 1):\n        for j in range(1, len(s) + 1):\n            for x in range(j - minLength, -1, -1):\n                if s[x] in primes and s[j - 1] not in primes:\n                    dp[i][j] = (dp[i][j] + dp[i - 1][x]) % mod\n\n    return dp[k][len(s)]\n```"}
{"task_id": "LeetCode-Hard/12", "completion": "\nfrom collections import defaultdict\nfrom typing import List\n\ndef rootCount(edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    n = len(edges) + 1\n    parent = [-1] * n\n    \n    def find(x):\n        if parent[x] == -1:\n            return x\n        parent[x] = find(parent[x])\n        return parent[x]\n    \n    for u, v in guesses:\n        graph[v].remove(u)\n        graph[u].remove(v)\n        pu, pv = find(u), find(v)\n        if pu != pv:\n            parent[pu] = pv\n    \n    roots = set()\n    for i in range(n):\n        if parent[i] == -1:\n            roots.add(find(i))\n    \n    cnt = 0\n    for root in roots:\n        correct = 0\n        for u, v in guesses:\n            if find(u) == root:\n                correct += 1\n        if correct >= k:\n            cnt += 1\n    \n    return cnt\n", "raw_completion": "```python\nfrom collections import defaultdict\nfrom typing import List\n\ndef rootCount(edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    n = len(edges) + 1\n    parent = [-1] * n\n    \n    def find(x):\n        if parent[x] == -1:\n            return x\n        parent[x] = find(parent[x])\n        return parent[x]\n    \n    for u, v in guesses:\n        graph[v].remove(u)\n        graph[u].remove(v)\n        pu, pv = find(u), find(v)\n        if pu != pv:\n            parent[pu] = pv\n    \n    roots = set()\n    for i in range(n):\n        if parent[i] == -1:\n            roots.add(find(i))\n    \n    cnt = 0\n    for root in roots:\n        correct = 0\n        for u, v in guesses:\n            if find(u) == root:\n                correct += 1\n        if correct >= k:\n            cnt += 1\n    \n    return cnt\n```"}
{"task_id": "LeetCode-Hard/20", "completion": "\nfrom collections import Counter\n\ndef countAnagrams(s: str) -> int:\n    words = s.split(\" \")\n    count = Counter(words)\n    num_anagrams = 1\n\n    for word_count in count.values():\n        num_anagrams *= factorial(word_count)\n\n    return num_anagrams % (10**9 + 7)\n", "raw_completion": "```python\nfrom collections import Counter\n\ndef countAnagrams(s: str) -> int:\n    words = s.split(\" \")\n    count = Counter(words)\n    num_anagrams = 1\n\n    for word_count in count.values():\n        num_anagrams *= factorial(word_count)\n\n    return num_anagrams % (10**9 + 7)\n```"}
{"task_id": "LeetCode-Hard/36", "completion": "\nfrom typing import List\n\ndef minCost(nums: List[int], cost: List[int]) -> int:\n    n = len(nums)\n    total_cost = 0\n    \n    for i in range(1, n):\n        if nums[i] != nums[i-1]:\n            total_cost += min(cost[i], cost[i-1])\n            cost[i] = max(cost[i], cost[i-1])\n    \n    return total_cost\n", "raw_completion": "```python\nfrom typing import List\n\ndef minCost(nums: List[int], cost: List[int]) -> int:\n    n = len(nums)\n    total_cost = 0\n    \n    for i in range(1, n):\n        if nums[i] != nums[i-1]:\n            total_cost += min(cost[i], cost[i-1])\n            cost[i] = max(cost[i], cost[i-1])\n    \n    return total_cost\n```"}
{"task_id": "LeetCode-Hard/15", "completion": "\ndef findCrossingTime(n: int, k: int, time: List[List[int]]) -> int:\n    def get_efficiency(worker):\n        return time[worker][0] + time[worker][2]\n\n    def get_worker_with_lowest_efficiency(workers):\n        min_efficiency = float('inf')\n        min_efficiency_worker = None\n        for worker in workers:\n            efficiency = get_efficiency(worker)\n            if efficiency < min_efficiency:\n                min_efficiency = efficiency\n                min_efficiency_worker = worker\n        return min_efficiency_worker\n\n    def move_boxes(boxes):\n        bridge_left_to_right = 0  # time taken by worker to cross the bridge from left to right\n        bridge_right_to_left = 0  # time taken by worker to cross the bridge from right to left\n        waiting_on_left = set()  # workers waiting on the left side of the bridge\n        waiting_on_right = set()  # workers waiting on the right side of the bridge\n\n        for i in range(n):  # iterate until all boxes are put in the new warehouse\n            if waiting_on_right:  # if workers are waiting on the right side of the bridge\n                worker = get_worker_with_lowest_efficiency(waiting_on_right)\n                waiting_on_right.remove(worker)\n                bridge_right_to_left = max(bridge_right_to_left, time[worker][2])\n                waiting_on_left.add(worker)\n            elif boxes:  # if at least one box remains at the old warehouse\n                worker = get_worker_with_lowest_efficiency(waiting_on_left)\n                waiting_on_left.remove(worker)\n                boxes -= 1\n                bridge_left_to_right = max(bridge_left_to_right, time[worker][0])\n                waiting_on_right.add(worker)\n            else:  # if no boxes remain and no worker is waiting on the right side\n                time_taken = max(bridge_left_to_right, bridge_right_to_left)\n                return time_taken\n\n        time_taken = max(bridge_left_to_right, bridge_right_to_left)\n        return time_taken\n\n    return move_boxes(n)\n", "raw_completion": "```python\ndef findCrossingTime(n: int, k: int, time: List[List[int]]) -> int:\n    def get_efficiency(worker):\n        return time[worker][0] + time[worker][2]\n\n    def get_worker_with_lowest_efficiency(workers):\n        min_efficiency = float('inf')\n        min_efficiency_worker = None\n        for worker in workers:\n            efficiency = get_efficiency(worker)\n            if efficiency < min_efficiency:\n                min_efficiency = efficiency\n                min_efficiency_worker = worker\n        return min_efficiency_worker\n\n    def move_boxes(boxes):\n        bridge_left_to_right = 0  # time taken by worker to cross the bridge from left to right\n        bridge_right_to_left = 0  # time taken by worker to cross the bridge from right to left\n        waiting_on_left = set()  # workers waiting on the left side of the bridge\n        waiting_on_right = set()  # workers waiting on the right side of the bridge\n\n        for i in range(n):  # iterate until all boxes are put in the new warehouse\n            if waiting_on_right:  # if workers are waiting on the right side of the bridge\n                worker = get_worker_with_lowest_efficiency(waiting_on_right)\n                waiting_on_right.remove(worker)\n                bridge_right_to_left = max(bridge_right_to_left, time[worker][2])\n                waiting_on_left.add(worker)\n            elif boxes:  # if at least one box remains at the old warehouse\n                worker = get_worker_with_lowest_efficiency(waiting_on_left)\n                waiting_on_left.remove(worker)\n                boxes -= 1\n                bridge_left_to_right = max(bridge_left_to_right, time[worker][0])\n                waiting_on_right.add(worker)\n            else:  # if no boxes remain and no worker is waiting on the right side\n                time_taken = max(bridge_left_to_right, bridge_right_to_left)\n                return time_taken\n\n        time_taken = max(bridge_left_to_right, bridge_right_to_left)\n        return time_taken\n\n    return move_boxes(n)\n```\n\nExplanation:\n- The function `findCrossingTime` takes three parameters `n`, `k`, and `time` and returns an integer representing the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\n- The function `get_efficiency` calculates the efficiency of a worker based on the time it takes for the worker to cross the bridge from left to right and from right to left.\n- The function `get_worker_with_lowest_efficiency` finds the worker with the lowest efficiency among the given set of workers.\n- The function `move_boxes` simulates the movement of workers and boxes across the bridge.\n- Inside the `move_boxes` function, the variables `bridge_left_to_right` and `bridge_right_to_left` keep track of the time taken by the worker to cross the bridge from left to right and from right to left respectively.\n- The set `waiting_on_left` keeps track of the workers waiting on the left side of the bridge, and the set `waiting_on_right` keeps track of the workers waiting on the right side of the bridge.\n- The function iterates until all the boxes are put in the new warehouse. If there are workers waiting on the right side of the bridge, the worker with the lowest efficiency is chosen to cross the bridge from right to left. If no worker is waiting on the right side, but there are still boxes at the old warehouse, the worker with the lowest efficiency is chosen to cross the bridge from left to right and pick up a box. If no boxes remain and no worker is waiting on the right side, the function returns the maximum time taken to cross the bridge from left to right and from right to left.\n- Finally, the function returns the output of the `move_boxes` function, which is the time taken for the last worker to reach the left bank of the river."}
{"task_id": "LeetCode-Hard/27", "completion": "\ndef countPalindromes(s: str) -> int:\n    mod = 10**9 + 7\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for l in range(2, n+1):\n        for i in range(n-l+1):\n            j = i + l - 1\n            if s[i] == s[j]:\n                dp[i][j] = (dp[i+1][j-1] * 2) % mod\n                left = i+1\n                right = j-1\n                while left <= right and s[left] != s[i]:\n                    left += 1\n                while left <= right and s[right] != s[i]:\n                    right -= 1\n                if left > right:\n                    dp[i][j] += 2\n                elif left == right:\n                    dp[i][j] += 1\n                else:\n                    dp[i][j] -= dp[left+1][right-1]\n            else:\n                dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]) % mod\n    return dp[0][n-1]\n", "raw_completion": "```python\ndef countPalindromes(s: str) -> int:\n    mod = 10**9 + 7\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for l in range(2, n+1):\n        for i in range(n-l+1):\n            j = i + l - 1\n            if s[i] == s[j]:\n                dp[i][j] = (dp[i+1][j-1] * 2) % mod\n                left = i+1\n                right = j-1\n                while left <= right and s[left] != s[i]:\n                    left += 1\n                while left <= right and s[right] != s[i]:\n                    right -= 1\n                if left > right:\n                    dp[i][j] += 2\n                elif left == right:\n                    dp[i][j] += 1\n                else:\n                    dp[i][j] -= dp[left+1][right-1]\n            else:\n                dp[i][j] = (dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]) % mod\n    return dp[0][n-1]\n```"}
{"task_id": "LeetCode-Hard/11", "completion": "\ndef findMinimumTime(tasks: List[List[int]]) -> int:\n    # Write your code here\n    \n", "raw_completion": "The final solution must begin with the snippet shown here:\n\n```python\ndef findMinimumTime(tasks: List[List[int]]) -> int:\n    # Write your code here\n    \n```\n\nTo complete the task, we can iterate through the tasks and find the maximum end time. This will give us the total time the computer needs to be turned on. The code can be completed as follows:\n\n```python\ndef findMinimumTime(tasks: List[List[int]]) -> int:\n    max_end_time = 0\n    for task in tasks:\n        max_end_time = max(max_end_time, task[1])\n    return max_end_time\n```"}
{"task_id": "LeetCode-Hard/1", "completion": "\nfrom typing import List\n\n\ndef collectTheCoins(coins: List[int], edges: List[List[int]]) -> int:\n    def dfs(node, parent):\n        nonlocal ans\n        coins_collected = coins[node]\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                coins_collected += dfs(neighbor, node)\n        if parent != -1 and coins_collected > 0:\n            ans += 2\n        return coins_collected - 1\n\n    graph = [[] for _ in range(len(coins))]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    ans = 0\n    dfs(0, -1)\n    return ans\n", "raw_completion": "```python\nfrom typing import List\n\n\ndef collectTheCoins(coins: List[int], edges: List[List[int]]) -> int:\n    def dfs(node, parent):\n        nonlocal ans\n        coins_collected = coins[node]\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                coins_collected += dfs(neighbor, node)\n        if parent != -1 and coins_collected > 0:\n            ans += 2\n        return coins_collected - 1\n\n    graph = [[] for _ in range(len(coins))]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    ans = 0\n    dfs(0, -1)\n    return ans\n```"}
{"task_id": "LeetCode-Hard/21", "completion": "\ndef countPartitions(nums: List[int], k: int) -> int:\n    n = len(nums)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            dp[i][j] = (dp[i-1][j-1] * nums[i-1] + dp[i-1][j]) % (10**9 + 7)\n    result = 0\n    for i in range(k, n + 1):\n        result = (result + dp[n][i]) % (10**9 + 7)\n    return result\n", "raw_completion": "```python\ndef countPartitions(nums: List[int], k: int) -> int:\n    n = len(nums)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            dp[i][j] = (dp[i-1][j-1] * nums[i-1] + dp[i-1][j]) % (10**9 + 7)\n    result = 0\n    for i in range(k, n + 1):\n        result = (result + dp[n][i]) % (10**9 + 7)\n    return result\n```"}
{"task_id": "LeetCode-Hard/7", "completion": "\nfrom typing import List\n\ndef minCost(basket1: List[int], basket2: List[int]) -> int:\n    # check if the length of both baskets is the same\n    if len(basket1) != len(basket2):\n        return -1\n    \n    # calculate the total cost of both baskets\n    total_cost = sum(basket1) + sum(basket2)\n    \n    # calculate the target cost for each basket\n    target_cost = total_cost // 2\n    \n    # sort both baskets in ascending order\n    basket1.sort()\n    basket2.sort()\n    \n    # check if there is a feasible solution\n    for i in range(len(basket1)):\n        if sum(basket1[:i+1]) + sum(basket2[:i+1]) >= target_cost:\n            return min(sum(basket1[:i+1]), sum(basket2[:i+1])) - (sum(basket1) + sum(basket2) - target_cost)\n    \n    return -1\n", "raw_completion": "```python\nfrom typing import List\n\ndef minCost(basket1: List[int], basket2: List[int]) -> int:\n    # check if the length of both baskets is the same\n    if len(basket1) != len(basket2):\n        return -1\n    \n    # calculate the total cost of both baskets\n    total_cost = sum(basket1) + sum(basket2)\n    \n    # calculate the target cost for each basket\n    target_cost = total_cost // 2\n    \n    # sort both baskets in ascending order\n    basket1.sort()\n    basket2.sort()\n    \n    # check if there is a feasible solution\n    for i in range(len(basket1)):\n        if sum(basket1[:i+1]) + sum(basket2[:i+1]) >= target_cost:\n            return min(sum(basket1[:i+1]), sum(basket2[:i+1])) - (sum(basket1) + sum(basket2) - target_cost)\n    \n    return -1\n```"}
{"task_id": "LeetCode-Hard/5", "completion": "\ndef minimumScore(s: str, t: str) -> int:\n    i, j, score = 0, 0, 0\n    while i < len(s) and j < len(t):\n        if s[i] == t[j]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n            score += 1\n    score += len(s) - i + len(t) - j\n    return score\n", "raw_completion": "```python\ndef minimumScore(s: str, t: str) -> int:\n    i, j, score = 0, 0, 0\n    while i < len(s) and j < len(t):\n        if s[i] == t[j]:\n            i += 1\n            j += 1\n        else:\n            i += 1\n            score += 1\n    score += len(s) - i + len(t) - j\n    return score\n```"}
{"task_id": "LeetCode-Hard/10", "completion": "\ndef findShortestCycle(n: int, edges: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(curr, prev, start, depth):\n        if depth > n:\n            return -1\n        if curr == start and depth > 2:\n            return depth\n        for neighbor in graph[curr]:\n            if neighbor == prev:\n                continue\n            cycle_len = dfs(neighbor, curr, start, depth + 1)\n            if cycle_len > 0:\n                return cycle_len\n        return -1\n    \n    min_cycle = float('inf')\n    for i in range(n):\n        cycle_len = dfs(i, -1, i, 1)\n        if cycle_len > 0:\n            min_cycle = min(min_cycle, cycle_len)\n    \n    if min_cycle == float('inf'):\n        return -1\n    return min_cycle\n", "raw_completion": "```python\ndef findShortestCycle(n: int, edges: List[List[int]]) -> int:\n    graph = [[] for _ in range(n)]\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(curr, prev, start, depth):\n        if depth > n:\n            return -1\n        if curr == start and depth > 2:\n            return depth\n        for neighbor in graph[curr]:\n            if neighbor == prev:\n                continue\n            cycle_len = dfs(neighbor, curr, start, depth + 1)\n            if cycle_len > 0:\n                return cycle_len\n        return -1\n    \n    min_cycle = float('inf')\n    for i in range(n):\n        cycle_len = dfs(i, -1, i, 1)\n        if cycle_len > 0:\n            min_cycle = min(min_cycle, cycle_len)\n    \n    if min_cycle == float('inf'):\n        return -1\n    return min_cycle\n```"}
{"task_id": "LeetCode-Hard/13", "completion": "\ndef waysToReachTarget(target: int, types: List[List[int]]) -> int:\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    \n    for count, marks in types:\n        for i in range(target, marks - 1, -1):\n            dp[i] += dp[i - marks]\n            dp[i] %= (10**9 + 7)\n    \n    return dp[target]\n", "raw_completion": "```python\ndef waysToReachTarget(target: int, types: List[List[int]]) -> int:\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    \n    for count, marks in types:\n        for i in range(target, marks - 1, -1):\n            dp[i] += dp[i - marks]\n            dp[i] %= (10**9 + 7)\n    \n    return dp[target]\n```"}
{"task_id": "LeetCode-Hard/14", "completion": "\nfrom math import gcd\nfrom typing import List\n\ndef findValidSplit(nums: List[int]) -> int:\n    def calc_gcd(a: int, b: int) -> int:\n        while b != 0:\n            a, b = b, a % b\n        return a\n\n    prefix = 1\n    suffix = 1\n    for i in range(len(nums)):\n        prefix *= nums[i]\n        suffix *= nums[-(i+1)]\n        if calc_gcd(prefix, suffix) == 1:\n            return i\n\n    return -1\n", "raw_completion": "```python\nfrom math import gcd\nfrom typing import List\n\ndef findValidSplit(nums: List[int]) -> int:\n    def calc_gcd(a: int, b: int) -> int:\n        while b != 0:\n            a, b = b, a % b\n        return a\n\n    prefix = 1\n    suffix = 1\n    for i in range(len(nums)):\n        prefix *= nums[i]\n        suffix *= nums[-(i+1)]\n        if calc_gcd(prefix, suffix) == 1:\n            return i\n\n    return -1\n```"}
{"task_id": "LeetCode-Hard/38", "completion": "\nfrom typing import List\n\ndef countSubarrays(nums: List[int], minK: int, maxK: int) -> int:\n    count = 0\n    for i in range(len(nums)):\n        if nums[i] >= minK and nums[i] <= maxK:\n            count += 1\n        for j in range(i+1, len(nums)):\n            if min(nums[i:j+1]) == minK and max(nums[i:j+1]) == maxK:\n                count += 1\n    return count\n", "raw_completion": "```python\nfrom typing import List\n\ndef countSubarrays(nums: List[int], minK: int, maxK: int) -> int:\n    count = 0\n    for i in range(len(nums)):\n        if nums[i] >= minK and nums[i] <= maxK:\n            count += 1\n        for j in range(i+1, len(nums)):\n            if min(nums[i:j+1]) == minK and max(nums[i:j+1]) == maxK:\n                count += 1\n    return count\n```"}
{"task_id": "LeetCode-Hard/23", "completion": "\nfrom typing import List\n\ndef isPossible(n: int, edges: List[List[int]]) -> bool:\n    degrees = [0] * (n + 1)\n    for edge in edges:\n        degrees[edge[0]] += 1\n        degrees[edge[1]] += 1\n    count_odd = 0\n    for degree in degrees:\n        if degree % 2 != 0:\n            count_odd += 1\n            if count_odd > 2:\n                return False\n    return True\n", "raw_completion": "```python\nfrom typing import List\n\ndef isPossible(n: int, edges: List[List[int]]) -> bool:\n    degrees = [0] * (n + 1)\n    for edge in edges:\n        degrees[edge[0]] += 1\n        degrees[edge[1]] += 1\n    count_odd = 0\n    for degree in degrees:\n        if degree % 2 != 0:\n            count_odd += 1\n            if count_odd > 2:\n                return False\n    return True\n```"}
{"task_id": "LeetCode-Hard/34", "completion": "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef getHeight(node):\n    if node is None:\n        return -1\n    else:\n        return max(getHeight(node.left), getHeight(node.right)) + 1\n\ndef removeSubtree(node, value):\n    if node is None:\n        return None\n        \n    if node.val == value:\n        return None\n        \n    node.left = removeSubtree(node.left, value)\n    node.right = removeSubtree(node.right, value)\n    return node\n\ndef treeQueries(root, queries):\n    result = []\n    for query in queries:\n        tmpRoot = root\n        tmpRoot = removeSubtree(tmpRoot, query)\n        result.append(getHeight(tmpRoot))\n    return result\n", "raw_completion": "```python\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef getHeight(node):\n    if node is None:\n        return -1\n    else:\n        return max(getHeight(node.left), getHeight(node.right)) + 1\n\ndef removeSubtree(node, value):\n    if node is None:\n        return None\n        \n    if node.val == value:\n        return None\n        \n    node.left = removeSubtree(node.left, value)\n    node.right = removeSubtree(node.right, value)\n    return node\n\ndef treeQueries(root, queries):\n    result = []\n    for query in queries:\n        tmpRoot = root\n        tmpRoot = removeSubtree(tmpRoot, query)\n        result.append(getHeight(tmpRoot))\n    return result\n```"}
{"task_id": "LeetCode-Hard/40", "completion": "\ndef numberOfPaths(grid: List[List[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0] % k\n    for i in range(1, m):\n        dp[i][0] = (dp[i-1][0] + grid[i][0]) % k\n    for j in range(1, n):\n        dp[0][j] = (dp[0][j-1] + grid[0][j]) % k\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = (dp[i-1][j] + dp[i][j-1] + grid[i][j]) % k\n    return dp[m-1][n-1]\n", "raw_completion": "```python\ndef numberOfPaths(grid: List[List[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    dp[0][0] = grid[0][0] % k\n    for i in range(1, m):\n        dp[i][0] = (dp[i-1][0] + grid[i][0]) % k\n    for j in range(1, n):\n        dp[0][j] = (dp[0][j-1] + grid[0][j]) % k\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = (dp[i-1][j] + dp[i][j-1] + grid[i][j]) % k\n    return dp[m-1][n-1]\n```\nNote: The code uses dynamic programming to calculate the number of paths whose sum is divisible by k. The dp table stores the modulo of the sums of each prefix path. The final result is stored in dp[m-1][n-1]."}
{"task_id": "LeetCode-Hard/35", "completion": "\nfrom typing import List\n\ndef makeSimilar(nums: List[int], target: List[int]) -> int:\n    operations = 0\n    for i in range(len(nums)):\n        difference = target[i] - nums[i]\n        if difference % 2 != 0:\n            operations += 1\n    return operations\n", "raw_completion": "```python\nfrom typing import List\n\ndef makeSimilar(nums: List[int], target: List[int]) -> int:\n    operations = 0\n    for i in range(len(nums)):\n        difference = target[i] - nums[i]\n        if difference % 2 != 0:\n            operations += 1\n    return operations\n```"}
{"task_id": "LeetCode-Hard/17", "completion": "\nfrom typing import List\n\ndef minCost(nums: List[int], k: int) -> int:\n    importance_val = k\n    cost = 0\n    \n    # Split the array into subarrays\n    subarrays = []\n    curr_subarray = []\n    \n    for num in nums:\n        curr_subarray.append(num)\n        \n        # Check if the trimmed subarray is empty\n        if len(set(curr_subarray)) < len(curr_subarray):\n            importance_val += len(curr_subarray) - len(set(curr_subarray))\n        \n        # Check if the cost of the current subarray is less than the cost of starting a new subarray\n        if importance_val * len(curr_subarray) < importance_val:\n            subarrays.append(curr_subarray)\n            curr_subarray = []\n    \n    # Add the last subarray to the list of subarrays\n    if curr_subarray:\n        subarrays.append(curr_subarray)\n    \n    # Calculate the total cost\n    for subarray in subarrays:\n        cost += importance_val + len(subarray)\n    \n    return cost\n", "raw_completion": "```python\nfrom typing import List\n\ndef minCost(nums: List[int], k: int) -> int:\n    importance_val = k\n    cost = 0\n    \n    # Split the array into subarrays\n    subarrays = []\n    curr_subarray = []\n    \n    for num in nums:\n        curr_subarray.append(num)\n        \n        # Check if the trimmed subarray is empty\n        if len(set(curr_subarray)) < len(curr_subarray):\n            importance_val += len(curr_subarray) - len(set(curr_subarray))\n        \n        # Check if the cost of the current subarray is less than the cost of starting a new subarray\n        if importance_val * len(curr_subarray) < importance_val:\n            subarrays.append(curr_subarray)\n            curr_subarray = []\n    \n    # Add the last subarray to the list of subarrays\n    if curr_subarray:\n        subarrays.append(curr_subarray)\n    \n    # Calculate the total cost\n    for subarray in subarrays:\n        cost += importance_val + len(subarray)\n    \n    return cost\n```"}
{"task_id": "LeetCode-Hard/8", "completion": "\nfrom typing import List\n\ndef countQuadruplets(nums: List[int]) -> int:\n    count = 0\n    \n    for i in range(len(nums) - 3):\n        for j in range(i + 1, len(nums) - 2):\n            for k in range(j + 1, len(nums) - 1):\n                for l in range(k + 1, len(nums)):\n                    if nums[i] < nums[k] < nums[j] < nums[l]:\n                        count += 1\n    \n    return count\n", "raw_completion": "```python\nfrom typing import List\n\ndef countQuadruplets(nums: List[int]) -> int:\n    count = 0\n    \n    for i in range(len(nums) - 3):\n        for j in range(i + 1, len(nums) - 2):\n            for k in range(j + 1, len(nums) - 1):\n                for l in range(k + 1, len(nums)):\n                    if nums[i] < nums[k] < nums[j] < nums[l]:\n                        count += 1\n    \n    return count\n```"}
{"task_id": "LeetCode-Hard/33", "completion": "\nfrom typing import List\n\ndef secondGreaterElement(nums: List[int]) -> List[int]:\n    result = []\n    n = len(nums)\n    for i in range(n):\n        second_greater = -1\n        for j in range(i+1, n):\n            if nums[j] > nums[i]:\n                if second_greater == -1 or nums[j] > nums[second_greater]:\n                    second_greater = j\n        result.append(nums[second_greater])\n    return result\n", "raw_completion": "```python\nfrom typing import List\n\ndef secondGreaterElement(nums: List[int]) -> List[int]:\n    result = []\n    n = len(nums)\n    for i in range(n):\n        second_greater = -1\n        for j in range(i+1, n):\n            if nums[j] > nums[i]:\n                if second_greater == -1 or nums[j] > nums[second_greater]:\n                    second_greater = j\n        result.append(nums[second_greater])\n    return result\n```"}
{"task_id": "LeetCode-Hard/3", "completion": "\nfrom string import ascii_lowercase\nfrom typing import List\n\ndef findTheString(lcp: List[List[int]]) -> str:\n    n = len(lcp)\n    res = []\n    \n    for i in range(n):\n        for j in range(n):\n            if lcp[i][j] < 0 or lcp[i][j] >= n - j:\n                return \"\"\n    \n    for i in range(n):\n        c = ascii_lowercase[i % 26]\n        res.append(c)\n        for j in range(i):\n            lcp[i][j] = lcp[j][i]\n        \n        for j in range(i + 1, n):\n            lcp[i][j] -= (i - 1) / 2\n        \n    return \"\".join(res)\n", "raw_completion": "```python\nfrom string import ascii_lowercase\nfrom typing import List\n\ndef findTheString(lcp: List[List[int]]) -> str:\n    n = len(lcp)\n    res = []\n    \n    for i in range(n):\n        for j in range(n):\n            if lcp[i][j] < 0 or lcp[i][j] >= n - j:\n                return \"\"\n    \n    for i in range(n):\n        c = ascii_lowercase[i % 26]\n        res.append(c)\n        for j in range(i):\n            lcp[i][j] = lcp[j][i]\n        \n        for j in range(i + 1, n):\n            lcp[i][j] -= (i - 1) / 2\n        \n    return \"\".join(res)\n```"}
{"task_id": "LeetCode-Hard/39", "completion": "\nfrom typing import List\n\ndef lengthOfLIS(nums: List[int], k: int) -> int:\n    if not nums:\n        return 0\n        \n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if abs(nums[i] - nums[j]) <= k:\n                dp[i] = max(dp[i], dp[j] + 1)\n            \n    return max(dp)\n", "raw_completion": "```python\nfrom typing import List\n\ndef lengthOfLIS(nums: List[int], k: int) -> int:\n    if not nums:\n        return 0\n        \n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if abs(nums[i] - nums[j]) <= k:\n                dp[i] = max(dp[i], dp[j] + 1)\n            \n    return max(dp)\n```"}
{"task_id": "LeetCode-Hard/9", "completion": "\nfrom typing import List\n\ndef putMarbles(weights: List[int], k: int) -> int:\n    n = len(weights)\n    dp = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            for x in range(j - 1, i):\n                dp[i][j] = min(dp[i][j], dp[x][j - 1] + sum(weights[x:i]))\n    return dp[n][k]\n", "raw_completion": "```python\nfrom typing import List\n\ndef putMarbles(weights: List[int], k: int) -> int:\n    n = len(weights)\n    dp = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            for x in range(j - 1, i):\n                dp[i][j] = min(dp[i][j], dp[x][j - 1] + sum(weights[x:i]))\n    return dp[n][k]\n```"}
{"task_id": "LeetCode-Hard/4", "completion": "\ndef handleQuery(nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n    result = []\n    for query in queries:\n        if query[0] == 1:\n            l, r = query[1], query[2]\n            for i in range(l, r+1):\n                nums1[i] = 1 - nums1[i]\n        elif query[0] == 2:\n            p = query[1]\n            for i in range(len(nums1)):\n                nums2[i] += nums1[i] * p\n        elif query[0] == 3:\n            result.append(sum(nums2))\n    return result\n", "raw_completion": "```python\ndef handleQuery(nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n    result = []\n    for query in queries:\n        if query[0] == 1:\n            l, r = query[1], query[2]\n            for i in range(l, r+1):\n                nums1[i] = 1 - nums1[i]\n        elif query[0] == 2:\n            p = query[1]\n            for i in range(len(nums1)):\n                nums2[i] += nums1[i] * p\n        elif query[0] == 3:\n            result.append(sum(nums2))\n    return result\n```"}
{"task_id": "LeetCode-Hard/37", "completion": "def componentValue(nums: List[int], edges: List[List[int]]) -> int:\n    # Create a dictionary to store the sum of values for each component\n    component_sum = {}\n    \n    # Function to calculate the sum of values for each component\n    def dfs(node, parent):\n        component_sum[node] = nums[node]\n        for neighbor in edges[node]:\n            if neighbor == parent:\n                continue\n            component_sum[node] += dfs(neighbor, node)\n        return component_sum[node]\n    \n    # Function to check if all components have the same value\n    def check_same_value(node, parent, total_sum):\n        for neighbor in edges[node]:\n            if neighbor == parent:\n                continue\n            if component_sum[neighbor] != total_sum:\n                return False\n            if not check_same_value(neighbor, node, total_sum):\n                return False\n        return True\n    \n    # Initialize variables\n    num_edges_deleted = 0\n    total_sum = dfs(0, -1)\n    \n    # Iterate through each edge\n    for edge in edges:\n        node1, node2 = edge\n        component_sum[node1] -= component_sum[node2]\n        component_sum[node2] -= component_sum[node1]\n        if component_sum[node1] == total_sum and check_same_value(node1, -1, total_sum):\n            num_edges_deleted += 1\n        if component_sum[node2] == total_sum and check_same_value(node2, -1, total_sum):\n            num_edges_deleted += 1\n    \n    # Return the maximum number of edges deleted\n    return num_edges_deleted", "raw_completion": "def componentValue(nums: List[int], edges: List[List[int]]) -> int:\n    # Create a dictionary to store the sum of values for each component\n    component_sum = {}\n    \n    # Function to calculate the sum of values for each component\n    def dfs(node, parent):\n        component_sum[node] = nums[node]\n        for neighbor in edges[node]:\n            if neighbor == parent:\n                continue\n            component_sum[node] += dfs(neighbor, node)\n        return component_sum[node]\n    \n    # Function to check if all components have the same value\n    def check_same_value(node, parent, total_sum):\n        for neighbor in edges[node]:\n            if neighbor == parent:\n                continue\n            if component_sum[neighbor] != total_sum:\n                return False\n            if not check_same_value(neighbor, node, total_sum):\n                return False\n        return True\n    \n    # Initialize variables\n    num_edges_deleted = 0\n    total_sum = dfs(0, -1)\n    \n    # Iterate through each edge\n    for edge in edges:\n        node1, node2 = edge\n        component_sum[node1] -= component_sum[node2]\n        component_sum[node2] -= component_sum[node1]\n        if component_sum[node1] == total_sum and check_same_value(node1, -1, total_sum):\n            num_edges_deleted += 1\n        if component_sum[node2] == total_sum and check_same_value(node2, -1, total_sum):\n            num_edges_deleted += 1\n    \n    # Return the maximum number of edges deleted\n    return num_edges_deleted"}
{"task_id": "LeetCode-Hard/6", "completion": "\nfrom typing import List\n\ndef minimumVisitedCells(grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    \n    # Create a dp table to store the minimum number of visited cells\n    dp = [[float('inf')] * n for _ in range(m)]\n    \n    dp[0][0] = 0\n    \n    # Traverse through the grid\n    for i in range(m):\n        for j in range(n):\n            if dp[i][j] == float('inf'):\n                continue\n            \n            # Rightward movement\n            for k in range(j+1, min(j + 1 + grid[i][j], n)):\n                dp[i][k] = min(dp[i][k], dp[i][j] + 1)\n                \n            # Downward movement\n            for k in range(i+1, min(i + 1 + grid[i][j], m)):\n                dp[k][j] = min(dp[k][j], dp[i][j] + 1)\n    \n    # If there is no valid path, return -1\n    if dp[m-1][n-1] == float('inf'):\n        return -1\n    \n    return dp[m-1][n-1]\n", "raw_completion": "```python\nfrom typing import List\n\ndef minimumVisitedCells(grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    \n    # Create a dp table to store the minimum number of visited cells\n    dp = [[float('inf')] * n for _ in range(m)]\n    \n    dp[0][0] = 0\n    \n    # Traverse through the grid\n    for i in range(m):\n        for j in range(n):\n            if dp[i][j] == float('inf'):\n                continue\n            \n            # Rightward movement\n            for k in range(j+1, min(j + 1 + grid[i][j], n)):\n                dp[i][k] = min(dp[i][k], dp[i][j] + 1)\n                \n            # Downward movement\n            for k in range(i+1, min(i + 1 + grid[i][j], m)):\n                dp[k][j] = min(dp[k][j], dp[i][j] + 1)\n    \n    # If there is no valid path, return -1\n    if dp[m-1][n-1] == float('inf'):\n        return -1\n    \n    return dp[m-1][n-1]\n```"}
{"task_id": "LeetCode-Hard/28", "completion": "\nfrom typing import List\n\ndef countSubarrays(nums: List[int], k: int) -> int:\n    count = 0\n    n = len(nums)\n\n    for i in range(n):\n        # Check subarrays with odd length\n        for j in range(i, n):\n            subarray = nums[i:j+1]\n            median = sorted(subarray)[len(subarray) // 2]\n            if median == k:\n                count += 1\n\n        # Check subarrays with even length\n        if i < n-1:\n            for j in range(i, n-1):\n                subarray = nums[i:j+2]\n                median = sorted(subarray)[len(subarray) // 2 - 1]\n                if median == k:\n                    count += 1\n\n    return count\n", "raw_completion": "```python\nfrom typing import List\n\ndef countSubarrays(nums: List[int], k: int) -> int:\n    count = 0\n    n = len(nums)\n\n    for i in range(n):\n        # Check subarrays with odd length\n        for j in range(i, n):\n            subarray = nums[i:j+1]\n            median = sorted(subarray)[len(subarray) // 2]\n            if median == k:\n                count += 1\n\n        # Check subarrays with even length\n        if i < n-1:\n            for j in range(i, n-1):\n                subarray = nums[i:j+2]\n                median = sorted(subarray)[len(subarray) // 2 - 1]\n                if median == k:\n                    count += 1\n\n    return count\n```"}
{"task_id": "LeetCode-Hard/18", "completion": "\nfrom typing import List\n\ndef maxOutput(n: int, edges: List[List[int]], price: List[int]) -> int:\n    def dfs(node, parent):\n        nonlocal max_cost\n        sub_prices = [price[node]]\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                sub_prices.append(dfs(neighbor, node))\n        max_price = max(sub_prices)\n        min_price = min(sub_prices)\n        max_cost = max(max_cost, max_price - min_price)\n        return sum(sub_prices)\n\n    tree = [[] for _ in range(n)]\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    max_cost = 0\n    dfs(0, -1)\n\n    return max_cost\n", "raw_completion": "```python\nfrom typing import List\n\ndef maxOutput(n: int, edges: List[List[int]], price: List[int]) -> int:\n    def dfs(node, parent):\n        nonlocal max_cost\n        sub_prices = [price[node]]\n        for neighbor in tree[node]:\n            if neighbor != parent:\n                sub_prices.append(dfs(neighbor, node))\n        max_price = max(sub_prices)\n        min_price = min(sub_prices)\n        max_cost = max(max_cost, max_price - min_price)\n        return sum(sub_prices)\n\n    tree = [[] for _ in range(n)]\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n    max_cost = 0\n    dfs(0, -1)\n\n    return max_cost\n```"}
{"task_id": "LeetCode-Hard/22", "completion": "\nfrom typing import List\n\ndef cycleLengthQueries(n: int, queries: List[List[int]]) -> List[int]:\n    # Define a helper function to find the root of a given node\n    def find_root(node):\n        while parent[node] != node:\n            parent[node] = parent[parent[node]]\n            node = parent[node]\n        return node\n    \n    # Initialize parent array and answer array\n    parent = [i for i in range(2 * n)]\n    answer = []\n    \n    # Define a function to add an edge and find the cycle length\n    def add_edge_and_find_cycle_length(node1, node2):\n        root1 = find_root(node1)\n        root2 = find_root(node2)\n        \n        if root1 == root2:\n            # If the two nodes are already in the same connected component, return the edge count\n            edge_count = 0\n            while node1 != node2:\n                node1 = parent[node1]\n                edge_count += 1\n            answer.append(edge_count)\n            return\n        \n        parent[root1] = root2\n        answer.append(1)\n    \n    # Iterate through each query\n    for query in queries:\n        node1, node2 = query\n        add_edge_and_find_cycle_length(node1, node2)\n        \n    return answer\n", "raw_completion": "```python\nfrom typing import List\n\ndef cycleLengthQueries(n: int, queries: List[List[int]]) -> List[int]:\n    # Define a helper function to find the root of a given node\n    def find_root(node):\n        while parent[node] != node:\n            parent[node] = parent[parent[node]]\n            node = parent[node]\n        return node\n    \n    # Initialize parent array and answer array\n    parent = [i for i in range(2 * n)]\n    answer = []\n    \n    # Define a function to add an edge and find the cycle length\n    def add_edge_and_find_cycle_length(node1, node2):\n        root1 = find_root(node1)\n        root2 = find_root(node2)\n        \n        if root1 == root2:\n            # If the two nodes are already in the same connected component, return the edge count\n            edge_count = 0\n            while node1 != node2:\n                node1 = parent[node1]\n                edge_count += 1\n            answer.append(edge_count)\n            return\n        \n        parent[root1] = root2\n        answer.append(1)\n    \n    # Iterate through each query\n    for query in queries:\n        node1, node2 = query\n        add_edge_and_find_cycle_length(node1, node2)\n        \n    return answer\n```"}
{"task_id": "LeetCode-Hard/30", "completion": "\nfrom typing import List\n\ndef splitMessage(message: str, limit: int) -> List[str]:\n    parts = []\n    num_parts = len(message) // limit + 1 if len(message) % limit != 0 else len(message) // limit\n    for i in range(num_parts):\n        start = i * limit\n        end = start + limit\n        if end > len(message):\n            end = len(message)\n        part = message[start:end]\n        parts.append(part + \"<{}/{}>\".format(i+1, num_parts))\n    return parts\n", "raw_completion": "```python\nfrom typing import List\n\ndef splitMessage(message: str, limit: int) -> List[str]:\n    parts = []\n    num_parts = len(message) // limit + 1 if len(message) % limit != 0 else len(message) // limit\n    for i in range(num_parts):\n        start = i * limit\n        end = start + limit\n        if end > len(message):\n            end = len(message)\n        part = message[start:end]\n        parts.append(part + \"<{}/{}>\".format(i+1, num_parts))\n    return parts\n```"}
{"task_id": "LeetCode-Hard/19", "completion": "\nfrom typing import List\n\ndef maxPower(stations: List[int], r: int, k: int) -> int:\n    n = len(stations)\n    left = 0\n    right = sum(stations)\n    result = 0\n    \n    while left <= right:\n        mid = (left + right) // 2\n        count = 0\n        extra_stations = k\n\n        for i in range(n):\n            if stations[i] < mid:\n                needed_stations = mid - stations[i]\n                if needed_stations <= extra_stations * (2 * r + 1):\n                    count += needed_stations\n                    extra_stations -= (needed_stations + r) // (2 * r + 1)\n                else:\n                    count += extra_stations * (2 * r + 1)\n                    extra_stations = 0\n\n        if count <= k * (2 * r + 1):\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n", "raw_completion": "```python\nfrom typing import List\n\ndef maxPower(stations: List[int], r: int, k: int) -> int:\n    n = len(stations)\n    left = 0\n    right = sum(stations)\n    result = 0\n    \n    while left <= right:\n        mid = (left + right) // 2\n        count = 0\n        extra_stations = k\n\n        for i in range(n):\n            if stations[i] < mid:\n                needed_stations = mid - stations[i]\n                if needed_stations <= extra_stations * (2 * r + 1):\n                    count += needed_stations\n                    extra_stations -= (needed_stations + r) // (2 * r + 1)\n                else:\n                    count += extra_stations * (2 * r + 1)\n                    extra_stations = 0\n\n        if count <= k * (2 * r + 1):\n            result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n```"}
{"task_id": "LeetCode-Hard/25", "completion": "\nfrom typing import List\n\ndef maxPoints(grid: List[List[int]], queries: List[int]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    result = []\n    \n    for query in queries:\n        points = 0\n        visited = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] < query and not visited[i][j]:\n                    points += 1\n                    visited[i][j] = True\n                    stack = [(i, j)]\n                    while stack:\n                        x, y = stack.pop()\n                        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                            nx = x + dx\n                            ny = y + dy\n                            if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] < query:\n                                points += 1\n                                visited[nx][ny] = True\n                                stack.append((nx, ny))\n        result.append(points)\n    \n    return result\n", "raw_completion": "```python\nfrom typing import List\n\ndef maxPoints(grid: List[List[int]], queries: List[int]) -> List[int]:\n    m = len(grid)\n    n = len(grid[0])\n    result = []\n    \n    for query in queries:\n        points = 0\n        visited = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] < query and not visited[i][j]:\n                    points += 1\n                    visited[i][j] = True\n                    stack = [(i, j)]\n                    while stack:\n                        x, y = stack.pop()\n                        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                            nx = x + dx\n                            ny = y + dy\n                            if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] < query:\n                                points += 1\n                                visited[nx][ny] = True\n                                stack.append((nx, ny))\n        result.append(points)\n    \n    return result\n```"}
{"task_id": "LeetCode-Hard/31", "completion": "\ndef maxPalindromes(s: str, k: int) -> int:\n    def isPalindrome(s: str) -> bool:\n        return s == s[::-1]\n        \n    count = 0\n    i = 0\n    while i+k <= len(s):\n        if isPalindrome(s[i:i+k]):\n            count += 1\n            i += k\n        else:\n            i += 1\n    return count\n", "raw_completion": "```python\ndef maxPalindromes(s: str, k: int) -> int:\n    def isPalindrome(s: str) -> bool:\n        return s == s[::-1]\n        \n    count = 0\n    i = 0\n    while i+k <= len(s):\n        if isPalindrome(s[i:i+k]):\n            count += 1\n            i += k\n        else:\n            i += 1\n    return count\n```"}
{"task_id": "LeetCode-Hard/32", "completion": "\nfrom typing import List\n\ndef minimumTotalDistance(robot: List[int], factory: List[List[int]]) -> int:\n    # Sort robot positions in ascending order\n    robot.sort()\n    \n    # Sort factory positions in ascending order\n    factory.sort()\n    \n    # Initialize the total distance to 0\n    total_distance = 0\n    \n    # Iterate through each factory\n    for position, limit in factory:\n        # Calculate the number of robots that will be repaired by this factory\n        robots_repaired = min(limit, len(robot))\n        \n        # Calculate the distance traveled by the robots to reach this factory\n        distance = abs(robot[robots_repaired-1] - position)\n        \n        # Add the distance to the total distance\n        total_distance += distance\n        \n        # Remove the repaired robots from the robot list\n        robot = robot[robots_repaired:]\n    \n    return total_distance\n", "raw_completion": "```python\nfrom typing import List\n\ndef minimumTotalDistance(robot: List[int], factory: List[List[int]]) -> int:\n    # Sort robot positions in ascending order\n    robot.sort()\n    \n    # Sort factory positions in ascending order\n    factory.sort()\n    \n    # Initialize the total distance to 0\n    total_distance = 0\n    \n    # Iterate through each factory\n    for position, limit in factory:\n        # Calculate the number of robots that will be repaired by this factory\n        robots_repaired = min(limit, len(robot))\n        \n        # Calculate the distance traveled by the robots to reach this factory\n        distance = abs(robot[robots_repaired-1] - position)\n        \n        # Add the distance to the total distance\n        total_distance += distance\n        \n        # Remove the repaired robots from the robot list\n        robot = robot[robots_repaired:]\n    \n    return total_distance\n```"}
{"task_id": "LeetCode-Hard/16", "completion": "\ndef isReachable(targetX: int, targetY: int) -> bool:\n    if targetX < 1 or targetY < 1:\n        return False\n    elif targetX == 1 and targetY == 1:\n        return True\n    elif targetX < targetY:\n        return isReachable(targetX, targetY - targetX)\n    else:\n        return isReachable(targetX - targetY, targetY)\n", "raw_completion": "```python\ndef isReachable(targetX: int, targetY: int) -> bool:\n    if targetX < 1 or targetY < 1:\n        return False\n    elif targetX == 1 and targetY == 1:\n        return True\n    elif targetX < targetY:\n        return isReachable(targetX, targetY - targetX)\n    else:\n        return isReachable(targetX - targetY, targetY)\n```"}
{"task_id": "LeetCode-Hard/2", "completion": "\ndef minimumTime(grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    \n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    \n    queue = [(0, 0)]\n    \n    while queue:\n        curr_row, curr_col = queue.pop(0)\n        \n        for dr, dc in directions:\n            new_row, new_col = curr_row + dr, curr_col + dc\n            \n            if 0 <= new_row < m and 0 <= new_col < n:\n                time = max(dp[curr_row][curr_col], grid[new_row][new_col])\n                if time < dp[new_row][new_col]:\n                    dp[new_row][new_col] = time\n                    queue.append((new_row, new_col))\n    \n    return dp[-1][-1] if dp[-1][-1] != float('inf') else -1\n", "raw_completion": "```python\ndef minimumTime(grid: List[List[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    \n    dp = [[float('inf')] * n for _ in range(m)]\n    dp[0][0] = 0\n    \n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    \n    queue = [(0, 0)]\n    \n    while queue:\n        curr_row, curr_col = queue.pop(0)\n        \n        for dr, dc in directions:\n            new_row, new_col = curr_row + dr, curr_col + dc\n            \n            if 0 <= new_row < m and 0 <= new_col < n:\n                time = max(dp[curr_row][curr_col], grid[new_row][new_col])\n                if time < dp[new_row][new_col]:\n                    dp[new_row][new_col] = time\n                    queue.append((new_row, new_col))\n    \n    return dp[-1][-1] if dp[-1][-1] != float('inf') else -1\n```"}
{"task_id": "LeetCode-Hard/26", "completion": "\nfrom typing import List\n\ndef magnificentSets(n: int, edges: List[List[int]]) -> int:\n    # Find the number of connected components using DFS\n    def dfs(node, group):\n        groups[node] = group\n        for neighbor in graph[node]:\n            if groups[neighbor] == -1:\n                dfs(neighbor, 1 - group)\n    \n    graph = [[] for _ in range(n + 1)]\n    for node1, node2 in edges:\n        graph[node1].append(node2)\n        graph[node2].append(node1)\n    \n    groups = [-1] * (n + 1)\n    num_groups = 0\n    for node in range(1, n + 1):\n        if groups[node] == -1:\n            dfs(node, 0)\n            num_groups += 1\n    \n    for node1, node2 in edges:\n        if groups[node1] == groups[node2]:\n            return -1\n    \n    return num_groups\n", "raw_completion": "```python\nfrom typing import List\n\ndef magnificentSets(n: int, edges: List[List[int]]) -> int:\n    # Find the number of connected components using DFS\n    def dfs(node, group):\n        groups[node] = group\n        for neighbor in graph[node]:\n            if groups[neighbor] == -1:\n                dfs(neighbor, 1 - group)\n    \n    graph = [[] for _ in range(n + 1)]\n    for node1, node2 in edges:\n        graph[node1].append(node2)\n        graph[node2].append(node1)\n    \n    groups = [-1] * (n + 1)\n    num_groups = 0\n    for node in range(1, n + 1):\n        if groups[node] == -1:\n            dfs(node, 0)\n            num_groups += 1\n    \n    for node1, node2 in edges:\n        if groups[node1] == groups[node2]:\n            return -1\n    \n    return num_groups\n```"}
{"task_id": "LeetCode-Hard/24", "completion": "\nfrom typing import List\n\ndef minimumTotalCost(nums1: List[int], nums2: List[int]) -> int:\n    if nums1 == nums2:\n        return -1\n    \n    n = len(nums1)\n    cost = 0\n    \n    for i in range(n):\n        if nums1[i] == nums2[i]:\n            return -1\n        else:\n            cost += i\n    \n    return cost\n", "raw_completion": "```python\nfrom typing import List\n\ndef minimumTotalCost(nums1: List[int], nums2: List[int]) -> int:\n    if nums1 == nums2:\n        return -1\n    \n    n = len(nums1)\n    cost = 0\n    \n    for i in range(n):\n        if nums1[i] == nums2[i]:\n            return -1\n        else:\n            cost += i\n    \n    return cost\n```"}
